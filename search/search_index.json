{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ACM Foundations 2023","text":"<p>This website contains the documentation and resources for ACM Foundations Sessions - 2023 organized by ACM.</p>"},{"location":"#overview","title":"Overview","text":"<p>These sessions work as standalone learning journeys. Together they will provide its audience the core foundation in this amazing field of programming.</p> <p>The Beginner sessions will be taught in C and prepare the audience to begin their programming journeys. The Advanced sessions will cover essential competetive programming concepts, solve questions and make the audience job ready!</p>"},{"location":"#sessions","title":"Sessions","text":""},{"location":"#beginner","title":"Beginner","text":"Session Topic 1 Programming Basics using C - 1 2 Programming Basics using C - 2 3 Programming Basics using C - 3 4 Pointers in C: A Guide to Mastering the Art"},{"location":"#advanced","title":"Advanced","text":"Session Topic 1 Graph Theory 2 Linked Lists, Stacks and Queues 3 Hash Sets and Hash Maps 4 Recursion and Dynamic Programming"},{"location":"#instructors","title":"Instructors","text":"<p>This workshop is conducted by the ACM Team</p>"},{"location":"Advanced-1/","title":"Graph Theory","text":""},{"location":"Advanced-1/#graph-theory","title":"Graph Theory","text":"<p><code>Graph</code>  is probably the data structure that has the closest resemblance to our daily life. There are many types of graphs describing the relationships in real life. For instance, our friend circle is a huge \u201cgraph\u201d.</p> <p></p> <p>Figure 1. An example of a undirected graph.</p> <p>In Figure 1 above, we can see that person G, B, and E are all direct friends of A, while person C, D, and F are indirect friends of A. This example is a social graph of friendship. So, what is the \u201cgraph\u201d data structure?</p>"},{"location":"Advanced-1/#types-of-graphs","title":"Types of \u201cgraphs\u201d","text":"<p>There are many types of \u201cgraphs\u201d. In this Explore Card, we will introduce three types of graphs:  undirected graphs, directed graphs, and weighted graphs.</p>"},{"location":"Advanced-1/#undirected-graphs","title":"Undirected graphs","text":"<p>The edges between any two vertices in an \u201cundirected graph\u201d do not have a direction, indicating a two-way relationship.</p> <p>Figure 1 is an example of an undirected graph.</p>"},{"location":"Advanced-1/#directed-graphs","title":"Directed graphs","text":"<p>The edges between any two vertices in a \u201cdirected graph\u201d graph are directional.</p> <p>Figure 2 is an example of a directed graph.</p> <p></p> <p>Figure 2. An example of a directed graph.</p>"},{"location":"Advanced-1/#weighted-graphs","title":"Weighted graphs","text":"<p>Each edge in a \u201cweighted graph\u201d has an associated weight. The weight can be of any metric, such as time, distance, size, etc. The most commonly seen \u201cweighted map\u201d in our daily life might be a city map. In Figure 3, each edge is marked with the distance, which can be regarded as the weight of that edge.</p> <p></p> <p>Figure 3. An example of a weighted graph.</p>"},{"location":"Advanced-1/#the-definition-of-graph-and-terminologies","title":"The Definition of \u201cgraph\u201d and Terminologies","text":"<p>\u201cGraph\u201d is a non-linear data structure consisting of vertices and edges. There are a lot of terminologies to describe a graph. If you encounter an unfamiliar term in the following Explore Card, you may look up the definition below.</p> <ul> <li>Vertex: In Figure 1, nodes such as A, B, and C are called vertices of the graph.</li> <li>Edge: The connection between two vertices are the edges of the graph. In Figure 1, the connection between person A and B is an edge of the graph.</li> <li> <p>Path: the sequence of vertices to go through from one vertex to another. In Figure 1, a path from A to C is [A, B, C], or [A, G, B, C], or [A, E, F, D, B, C].</p> <p>Note: there can be multiple paths between two vertices.</p> </li> <li> <p>Path Length: the number of edges in a path. In Figure 1, the path lengths from person A to C are 2, 3, and 5, respectively.</p> </li> <li>Cycle: a path where the starting point and endpoint are the same vertex. In Figure 1, [A, B, D, F, E] forms a cycle. Similarly, [A, G, B] forms another cycle.</li> <li>Negative Weight Cycle: In a \u201cweighted graph\u201d, if the sum of the weights of all edges of a cycle is a negative value, it is a negative weight cycle. In Figure 4, the sum of weights is -3.</li> <li>Connectivity: if there exists at least one path between two vertices, these two vertices are connected. In Figure 1, A and C are connected because there is at least one path connecting them.</li> <li>Degree of a Vertex: the term \u201cdegree\u201d applies to unweighted graphs. The degree of a vertex is the number of edges connecting the vertex. In Figure 1, the degree of vertex A is 3 because three edges are connecting it.</li> <li>In-Degree: \u201cin-degree\u201d is a concept in directed graphs. If the in-degree of a vertex is d, there are d directional edges incident to the vertex. In Figure 2, A\u2019s indegree is 1, i.e., the edge from F to A.</li> <li>Out-Degree: \u201cout-degree\u201d is a concept in directed graphs. If the out-degree of a vertex is d, there are d edges incident from the vertex. In Figure 2, A\u2019s outdegree is 3, i,e, the edges A to B, A to C, and A to G.</li> </ul> <p></p> <p>Figure 4. An example of a negative weight cycle.</p>"},{"location":"Advanced-1/#representations-of-graph","title":"Representations of Graph","text":"<p>Here are the two most common ways to represent a graph :</p> <ol> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ol>"},{"location":"Advanced-1/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>An adjacency matrix is a way of representing a graph as a matrix of boolean (0\u2019s and 1\u2019s).</p> <p>Let\u2019s assume there are *n vertices in the graph So, create a 2D matrix adjMat[n][n]* having dimension n x n.</p> <ul> <li>If there is an edge from vertex *i to j, mark adjMat[i][j] as 1*.</li> <li>If there is no edge from vertex *i to j, mark adjMat[i][j] as 0*.</li> </ul>"},{"location":"Advanced-1/#representation-of-undirected-graph-to-adjacency-matrix","title":"Representation of Undirected Graph to Adjacency Matrix:","text":"<p>The below figure shows an undirected graph. Initially, the entire Matrix is \u200b\u200binitialized to *0. If there is an edge from source to destination, we insert 1 to both cases (adjMat[destination] and adjMat[destination])* because we can go either way.</p> <p></p>"},{"location":"Advanced-1/#representation-of-directed-graph-to-adjacency-matrix","title":"Representation of Directed Graph to Adjacency Matrix:","text":"<p>The below figure shows a directed graph. Initially, the entire Matrix is \u200b\u200binitialized to *0. If there is an edge from source to destination, we insert 1 for that particular adjMat[destination]*.</p> <p></p>"},{"location":"Advanced-1/#adjacency-list","title":"Adjacency List","text":"<p>An array of Lists is used to store edges between two vertices. The size of array is equal to the number of *vertices (i.e, n). Each index in this array represents a specific vertex in the graph. The entry at the index i of the array contains a linked list containing the vertices that are adjacent to vertex i*.</p> <p>Let\u2019s assume there are *n vertices in the graph So, create an array of list of size n as adjList[n].*</p> <ul> <li>adjList[0] will have all the nodes which are connected (neighbour) to vertex *0*.</li> <li>adjList[1] will have all the nodes which are connected (neighbour) to vertex *1* and so on.</li> </ul>"},{"location":"Advanced-1/#representation-of-undirected-graph-to-adjacency-list","title":"Representation of Undirected Graph to Adjacency list:","text":"<p>The below undirected graph has 3 vertices. So, an array of list will be created of size 3, where each indices represent the vertices. Now, vertex 0 has two neighbours (i.e, 1 and 2). So, insert vertex 1 and 2 at indices 0 of array. Similarly, For vertex 1, it has two neighbour (i.e, 2 and 1) So, insert vertices 2 and 1 at indices 1 of array. Similarly, for vertex 2, insert its neighbours in array of list.</p> <p></p>"},{"location":"Advanced-1/#representation-of-directed-graph-to-adjacency-list","title":"Representation of Directed Graph to Adjacency list:","text":"<p>The below directed graph has 3 vertices. So, an array of list will be created of size 3, where each indices represent the vertices. Now, vertex 0 has no neighbours. For vertex 1, it has two neighbour (i.e, 0 and 2) So, insert vertices 0 and 2 at indices 1 of array. Similarly, for vertex 2, insert its neighbours in array of list.</p> <p></p>"},{"location":"Advanced-1/#common-algorithms","title":"Common algorithms","text":""},{"location":"Advanced-1/#bfs","title":"BFS:","text":"<p>Breadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored.  </p> <p>BFS is actually traversing the nodes level by level. That is, traversing the node first, then its children and then its children\u2019s children. If you consider the following tree,</p> <p></p> <p>The root node is A. Its left and right children are  B  and  C. Further its children are  D,E,F  and  G. So the  BFS  of the above tree is</p> <pre><code>          ABCDEFG\n</code></pre> <p>Here  Level Order traversal  of a tree is going to be same as  BFS  since it traverse starting from level 0 till its last level. But not every BFS is level order traversal. For example,</p> <p></p> <p>Here the  BFS  traverse its left and right children first and then its children.</p> <p>So the BFS traversal of the above tree is  12345. Whereas Level Order traverse level by level. So the level order traversal of the same tree is  13245.</p> <p>Traversing the graph in BFS way is again going to be same. That visiting the nodes wider as the graph goes. Consider the following graph,</p> <p></p> <p>Let\u2019s traverse starting from Node  0, we first visit  0  and traversing its neighbouring nodes  1  and  2.</p> <p></p> <p></p> <p>Further traversing the next wider level  2  and  5. And Finally  4.</p> <p></p> <p></p> <p>Implementation: BFS: FIFO (First In First Out) In Breadth-First-Search,  queue  is going to be our hero. Here are the steps to implement BFS programmatically.</p> <ol> <li>Put the visited node in queue.</li> <li>Explore its children, add them to queue, and remove the visited node.</li> <li>Visit all the nodes until queue becomes empty.</li> </ol> <p></p> <p>In the above tree,</p> <ol> <li>we first put the root node  A  in queue.  A\u2019s children are  B  and  C. Add them to queue and remove  A.</li> <li>Further pull  B, add its children  D  and  E  to queue and remove  B.</li> <li>Pull  C, add its children  F  and  G  to queue and remove  C.</li> <li>D,E,F  and  G  have no children, so pop them from queue.</li> </ol>"},{"location":"Advanced-1/#question-shortest-path-to-food","title":"Question : Shortest path to food","text":"<p>Description</p> <p>You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.</p> <p>You are given an  <code>m x n</code>  character matrix,  <code>grid</code>, of these different types of cells:</p> <ul> <li><code>'*'</code>  is your location. There is  exactly one <code>'*'</code>  cell.</li> <li><code>'#'</code>  is a food cell. There may be  multiple  food cells.</li> <li><code>'O'</code>  is free space, and you can travel through these cells.</li> <li><code>'X'</code>  is an obstacle, and you cannot travel through these cells.</li> </ul> <p>You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.</p> <p>Return  the  length  of the shortest path for you to reach  any  food cell. If there is no path for you to reach food, return  <code>-1</code>.</p> <p>Example 1:</p> <p></p> <p>Input: grid = [[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]]</p> <p>Output: 3</p> <p>Explanation: It takes 3 steps to reach the food.</p> <p>Example 2:</p> <p></p> <p>Input: grid = [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"#\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]</p> <p>Output: -1</p> <p>Explanation: It is not possible to reach the food.</p> <p>Example 3:</p> <p></p> <p>Input: grid = [[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"O\",\"X\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]]</p> <p>Output: 6</p> <p>Explanation: There can be multiple food cells. It only takes 6 steps to reach the bottom food.</p> <p>Constraints:</p> <ul> <li><code>m == grid.length</code></li> <li><code>n == grid[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 200</code></li> <li><code>grid[row][col]</code>  is  <code>'*'</code>,  <code>'X'</code>,  <code>'O'</code>, or  <code>'#'</code>.</li> <li>The  <code>grid</code>  contains  exactly one <code>'*'</code>.</li> </ul> <p>Solution</p> <p><pre><code>from collections import deque\nclass Solution:\n    def getFood(self, grid):\n        m, n = len(grid), len(grid[0]) #Finding the number of rows and comuns\n        for p in range(m): #Finding the root, from where the BFS will start, which is where the person is standing now\n            for q in range(n):\n                if grid[p][q] == '*':\n                    i, j = p, q\n                    break\n        q = deque([(i, j)]) #Creating the Queue for the BFS\n        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)] # For moving up, down, right and left\n        steps = 0 #For storing the number of steps\n        while q: #Doing BFS till Queue is empty\n            steps += 1 #Adding one step for every level we go into the bfs\n            for temp in range(len(q)): #This is to visit all the nodes in the current level of the tree\n                i, j = q.popleft()\n                for a, b in directions: #Exploring every direction\n                    x, y = i + a, j + b\n                    if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n:\n                        if grid[x][y] == '#': #If food found its a success and we can leave\n                            return steps\n                        if grid[x][y] == 'O': #If an empty area found we move there and mark it as a X, to show that it is visited\n                            q.append((x, y))\n                            grid[x][y] = 'X'  # To mark as visited\n                        if grid[x][y] == 'X': #If the block is unreachable or visited we don't explore again\n                            continue\n        return -1\n\nSoln = Solution()\nprint(Soln.getFood([[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"*\",\"O\",\"X\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"O\",\"#\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]]))\n</code></pre> Notes:  Visualization of BFS with first 3 layers. A - root node/first lavel, C/M/B/O - second layer, D/N/L/J - third layer.  </p> <ol> <li>Algorithm uses queue for implementation.</li> <li>It checks whether a vertex has been explored before enqueueing the vertex.</li> <li>We can track if the node was already explored by modifying the original matrix.</li> <li>BFS algorithm can be instructed with additional array dist which can help to     track the parent node of the next node. This will help to reconstruct the path     by looping backward from end node.</li> </ol>"},{"location":"Advanced-1/#dfs","title":"DFS:","text":"<p>Is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</p> <p>As BFS traverse wide, DFS goes deep. It starts from first node, and goes deep in a path till it traverse the leaf node/the last node before start traversing its next path.</p> <p></p> <p>In the above tree, it first starts from root node  1, does deep to  2  and more deeper to  4. Node  4  has no children, so it is done with that path visits  5  and traverse back to  1  and starts visiting deep  3,6  and  7.</p> <p>Further we can traverse in three different ways,</p> <ol> <li>Pre-Order:  Visiting  root  first,  left  node next and finally  right  node.</li> <li>Inorder:  Visiting  left  first,  root  node next and finally  right  node.</li> <li>Post-Order:  Visiting  left  first,  right  node next and finally  root  node.</li> </ol> <p>So the traversal of above tree is going to be,</p> <pre><code>Pre-Order: 1245367\nInorder: 4251637\nPost-Order: 4526731\n</code></pre> <p>DFS of graph is also goes  deep  till it traverse all the nodes in the graph.</p> <p></p> <p>Implementation: DFS: LIFO (Last In First Out) We are going to get the help of  stack, in order to traverse the tree/graph DFS way.</p> <ol> <li>Add the visited Node to stack.</li> <li>Pop the Node from stack, explore its children and add them to stack.</li> <li>Explore all the nodes till stack becomes empty.     Here we are going to see pre-order traversal of the below tree using stack. Same technique can be used to perform both inorder and post-order traversals just by changing the order of visiting nodes.</li> </ol> <p></p>"},{"location":"Advanced-1/#question-keys-and-rooms","title":"Question: Keys and Rooms","text":"<p>Description There are  <code>n</code>  rooms labeled from  <code>0</code>  to  <code>n - 1</code> and all the rooms are locked except for room  <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p> <p>When you visit a room, you may find a set of  distinct keys  in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p> <p>Given an array  <code>rooms</code>  where  <code>rooms[i]</code>  is the set of keys that you can obtain if you visited room  <code>i</code>, return  <code>true</code> if you can visit  all  the rooms, or <code>false</code> otherwise.</p> <p>Example 1:</p> <p>Input: rooms = [[1,3],[3,0,1],[2],[0]]</p> <p>Output: false</p> <p>Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.</p> <p>Example 2:</p> <p>Input: rooms = [[1,3],[3,0,1],[0],[2]]</p> <p>Output: true</p> <p>Explanation:  We visit room 0 and pick up key 1. We then visit room 1 and pick up key 3. We then visit room 3 and pick up key 2. We then visit room 3 and pick up key 0. Since we were able to visit every room, we return true.</p> <p>Constraints:</p> <ul> <li><code>n == rooms.length</code></li> <li><code>2 &lt;= n &lt;= 1000</code></li> <li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li> <li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li> <li><code>0 &lt;= rooms[i][j] &lt; n</code></li> <li>All the values of  <code>rooms[i]</code>  are  unique.</li> </ul> <p>In above example,</p> <ol> <li>First we are visiting Node  1, add them to stack, explore its children and add its right child  3  first and then left child  2.</li> <li>Now the stack has nodes  2  and  3. Explore  2\u2019s children and add its right child  5  and then its left child  4  to stack. And pop  2.</li> <li>Further pop nodes from stack and add its children until stack becomes empty.</li> </ol> <p>Solution -   The basic idea of the code is to keep a record of all the keys you have already obtained. -   You can obtain all the keys in the rooms that you can go to -   And if the count of all the keys you can obtain is equal to the number of rooms, your answer is True.</p> <p>Code</p> <p><pre><code>from collections import deque\nclass Solution:\n    def canVisitAllRooms(self, rooms):\n        visited=[False]*len(rooms) #The visited array for the DFS to make sure we don't explore visited nodes again\n        stack=deque() #The stack for carrying the BFS\n        stack.append(0) #We know the root node is 0 since it is marked in the question, so we add it\n\n        while(len(stack)&gt;0): #DFS till stack is empty\n            key=stack.pop()\n            visited[key]=True #Marking node as visited, it can be done while adding into stack as well, like in the last question\n            for j in rooms[key]: #Exploring all options, the keys found in the new room\n                if(visited[j]==False):\n                    stack.append(j)\n\n\n        for i in visited:#If all rooms are visited the result is True, else False\n            if(i==False):\n                return False\n        return True                    \n\n\nSoln = Solution()\nprint(Soln.canVisitAllRooms([[1],[2],[3],[]]))\n</code></pre> Notes:</p> <ol> <li>Algorithm usually uses recursion implementation.</li> <li>We mark the node as visited and will keep exploring its neighbors if there are not yet explored.</li> <li>DFS can be useful to find connected components. We can iterate through the nodes and call dfs() to find all nodes which belongs to component.</li> <li>We can use unordered_map to represent the graph."},{"location":"Advanced-1/#minimum-spanning-tree-prims-algorithm","title":"Minimum Spanning Tree (Prim's Algorithm):","text":"<p>Minimum Spanning Tree (MST) is a spanning tree with  least possible edge weight. What that means is that it is an undirected graph, where all the vertices are connected, with least possible edge weight, and no cycles. A weighted, undirected, and connected graph can have many spanning trees but  only one  MST.</p> <p>Here is an image of a weighted, undirected, and connected graph. Blue edges are all the spanning trees of this graph and  red edges are the minimum spanning tree  (We will only use MST for all the future explanations in this guide.)</p> <p></p> <p>The total number of vertices, V in this Graph are 6. The total number of edges, E in an MST is  (V-1)  i.e. 6-1=5 edges. This is what the MST looks like for the above graph-</p> <p></p> <p>Alright, now that we have a basic understanding of how MST is supposed to be, let\u2019s try and understand how to find a minimum spanning tree when given a graph!</p> <p>Prim's Algorithm Prim\u2019s algorithm is a greedy algorithm. To find the MST using Prim\u2019s, we pick an initial starting vertex and add it to a set. Then we grow the MST from that initial vertex by adding adjacent vertices one by one based on least value of edge weight.</p> <p>Let\u2019s create 2 disjoint (no common value) subsets of vertices, one is called StartSet and the other is called MstSet. StartSet is a key value pair with vertices and their distances from the adjacent vertix that has been added to the MstSet. In the beginning, StartSet has all the vertices and MstSet has nothing.</p> <pre><code>StartSet: {(A, INF), (B, INF), (C, INF), (D, INF), (E, INF), (F, INF)}\nMstSet: {}\n</code></pre> <p>Let\u2019s pick a starting point. It doesn\u2019t matter which one because MST is unique and no matter where you start, you are going to end up with the same tree.</p> <p>I will begin at vertex C. From vertex C, we have the following paths- </p> <p>Since we picked our starting point, let's add vertex C to MstSet and update it's value to 0 in StartSet (as it is our initial vertex and distant from a node to itself is 0. Also update the values of vertices adjacent to C with their distances from C. Since A, D and E are adjacent to C, their values in StartSet are updated. Our subsets look as follows-</p> <pre><code>StartSet: {(A, 7), (B, INF), (C, 0), (D, 2), (E, 3), (F, INF)}\nMstSet: {C}\n</code></pre> <p>From C, we can either pick A, D, or E as our next vertex. Since the Prim's algorithm is Greedy, it will choose the path of least value i.e. the edge between C and D and will add vertex D to MstSet.  Next, the same process repeats with D. Update the value of vertices adjacent to D in StartSet. One thing to note here is that the distance of A from D is 6 which is less than distance of A from C. Therefore, in our subset StartSet, the value of A will update to 6 from 7. Same goes for E whose value will be updated from 3 to 1. Let's look at the values in our subsets-</p> <pre><code>StartSet: {(A, 6), (B, 7), (C, 0), (D, 2), (E, 1), (F, INF)}\nMstSet: {C, D}\n</code></pre> <p>So far we have C and D in our MST. Let's grow our MST some more by picking the next vertex.</p> <p>Now our edge values are 6, 7 and 1. Since 1 is smallest, the next vertex to be added to the MstSet will be E. You can also look at our subsets and see that out of all the vertices that are currently not in MstSet, E has the least value.  Continuing our tradition of updating adjacent vertices in StartSet, B is updated to 5 and F is updated to 4. Our subsets currently look like this-</p> <pre><code>StartSet: {(A, 6), (B, 5), (C, 0), (D, 2), (E, 1), (F, 4)}\nMstSet: {C, D, E}\n</code></pre> <p>Now we may have a problem! The values of edges coming from E are 3, 4 and 5. Since 3 is smaller than the 2, ideally we should pick that. However, we can't do that because C is already in MstSet. So we will go a step further and pick the edge with value 4 i.e. the E-F edge. Once again, add F to MstSet and update the adjacent vertices' values. </p> <p>There is no change of values for vertices adjacent to F. Let's take a quick look at our subsets after adding F.</p> <pre><code>StartSet: {(A, 6), (B, 5), (C, 0), (D, 2), (E, 1), (F, 4)}\nMstSet: {C, D, E, F}\n</code></pre> <p>Now the only vertices that are not in MstSet are A and B. As you can see from the subset, between A and B, B has the smaller value (5). Also in the graph, the least value of edge weight to reach B is 5 (E-B edge) as compared to A which is 7 (F-A edge).</p> <p>Therefore, we will go ahead and add B to our MstSet and update the values of it's adjacent vertices. Value of A is updated to 3. Our subsets look like this-</p> <pre><code>StartSet: {(A, 3), (B, 5), (C, 0), (D, 2), (E, 1), (F, 4)}\nMstSet: {C, D, E, F, B}\n</code></pre> <p>Now, only A needs to be added. As we can see from both the graph and the subset, the least cost way to reach A is through A-B edge.  So, we will add A to our MstSet. Let's look at the final values of our subsets-</p> <pre><code>StartSet: {(A, 3), (B, 5), (C, 0), (D, 2), (E, 1), (F, 4)}\nMstSet: {C, D, E, F, B, A}\n</code></pre> <p>All the vertices have been added to the MstSet! And finally, we have our Minimum Spanning Tree. </p>"},{"location":"Advanced-1/#question-optimized-water-distribution-in-a-village","title":"Question: Optimized water distribution in a village","text":"<p>Description</p> <p>There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.</p> <p>For each house i, we can either build a well inside it directly with cost wells[i], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[i] = [house1, house2, cost] represents the cost to connect house1 and house2 together using a pipe. Connections are bidirectional.</p> <p>Find the minimum total cost to supply water to all houses.</p> <p>Example 1:</p> <p>Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]</p> <p>Output: 3</p> <p>Explanation:  The image shows the costs of connecting houses using pipes. The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.</p> <p>Constraints:</p> <ul> <li>1 &lt;= n &lt;= 10000 </li> <li>wells.length == n </li> <li>0 &lt;= wells[i] &lt;= 10^5 </li> <li>1 &lt;= pipes.length &lt;= 10000 </li> <li>1 &lt;= pipes[i][0], pipes[i][1] &lt;= n </li> <li>0 &lt;= pipes[i][2] &lt;= 10^5 </li> <li>pipes[i][0] != pipes[i][1] </li> </ul> <p>example 1 pic:</p> <p></p> <p>Code</p> <pre><code>from collections import deque\nimport collections\nimport heapq\nclass Solution:\n    def minCostToSupplyWater(self, n, wells, pipes):\n        c = collections.defaultdict(list) #First step is creating the adjacency list to represent the graph\n\n        #The question as of now is not in MST since nodes value cost as well, this can be converted to MST by adding a base node\n        #This base node will have edge with every node with a weight equivalent to the cost of that node, and will also serve as the root node\n        for i, cost in enumerate(wells, 1): #Adding all the edges to the base node, cost equal to cost of well\n            c[0].append((cost, i))\n            c[i].append((cost, 0))\n        for i, j, cost in pipes: #Adding all other edges as adjacency list, cost first so it can be used in a heap\n            c[i].append((cost, j))\n            c[j].append((cost, i))\n\n        ans, visited, heap = 0, [0] * (n+1), c[0] #Answer is the final minimum cost, visited is the visited array, heap is to carry the Prim's\n        visited[0] = 1 #Starting with the root, our case the node we added, node 0\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]: #Only visiting unvisited nodes\n                visited[j], cnt, ans = 1, cnt+1, ans+d #For adding to our heap, each edge adds to the cost of the spanning tree \n                for record in c[j]: heapq.heappush(heap, record) #Adding the new node to our heap    \n        return ans                  \n\n\nSoln = Solution()\nprint(Soln.minCostToSupplyWater(3, [1,2,2], [[1,2,1],[2,3,1]]))\n</code></pre>"},{"location":"Advanced-1/#dijkstras-algorithm","title":"Dijkstra's algorithm:","text":"<p>Is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.</p> <p>Dijkstra's algorithm is a  Single-Source-Shortest-Path algorithm, which means that it calculates shortest distance from one vertex to all the other vertices.</p> <p>The node from where we want to find the shortest distance is known as the  source node. For the rest of the tutorial, I'll always label the source node as  S. And the distance to source node is naturally going to be  zero.</p> <pre><code>So, if we had an array of distances called dist[] and source node is 2 then dist[] would be \n[INF, INF, 0, INF, INF] \n  0    1   2   3    4\n// Consider INF as infinity since we don't know what the actual distance is. But we are very much sure that the distance to the source node is 0.\n</code></pre> <p>Let's start.</p> <p>Have a look at the image below. We shall work with it in this tutorial. </p> <p>Remember what I said about the source node? I said that we were  SURE  that the shortest distance to source node is going to be zero. Do you agree with me on that point? Of course, yes, because there was no path to travel.</p> <p>What does the distance array for our graph look like?</p> <pre><code>Node     |  S   A   B   C   D \nDistance |  0  INF INF INF INF\n</code></pre> <p>Let's break the problem. Let's rip apart this graph.</p> <p>We are at S currently. Let's see where we can go from S. </p> <p>You are at node S. There are 2 edges that come out of S. One edge goes to A and other goes to B. Edge SA distance is 15 and edge SB distance if 10. You can clearly verify this in the figure.</p> <p>I now claim that I am SURE that the shortest distance to B is 10. Why though? How many other ways are possible, through which you can reach to node B? Maybe there will be some edge from A to B. But since distance to A is already 15, any edge from A to B will only increase that distance and will never be able to become less than 10. This is the most important step. Read it again if you did not get it.</p> <p>Now, that I am SURE of the shortest distance to reach B, I discover more vertices from B.</p> <p>Now, our exploration graph looks something like this.  and the distance array has been updated.</p> <pre><code>Node     |  S   A   B   C   D \nDistance |  0  INF  10 INF INF\n</code></pre> <p>Let's see what the current scenario looks like.</p> <p>Nodes for which we know the shortest distance: S and B.</p> <p>What are we looking at now?</p> <p>At all the nodes we can reach from the S and B.</p> <p>Again, the same question. Which node's shortest distance can we be SURE of ?</p> <p>I claim it's node D. Look at the figure again.  The distance to D is 10 + 1 = 11, and no other path can have length smaller than this since their own distances are greater than 11.</p> <p>Hence, we now include D in our set of vertices for which shortest distances is known. Also, we explore more edges going from node D.</p> <p>Note that we are always picking the green vertex with the minimum distance.</p> <p>So, now our exploration graph looks something like this.</p> <p> Distance has been updated.</p> <pre><code>Node     |  S   A   B   C   D \nDistance |  0  INF  10 INF  11\n</code></pre> <p>Now, same question. Which node's shortest distance can we be SURE of? More specifically. Which green node's shortest distance can we be SURE of? Yes, right. It is C because the path S-B-D-C gives distance of 10 + 1 + 3 = 14 which is the lowest.</p> <p>Hence, we include C into the set of nodes for which final distance have been finalized and we also explore it's neighbours.</p> <p>The exploration graph now looks like this.  Distance has been updated again.</p> <pre><code>Node     |  S   A   B   C   D \nDistance |  0  INF  10  14  11\n</code></pre> <p>Again, for which node are we SURE of? There is just one node remaining and so it is the shortest. So, we include it in the set of nodes whose final distances are known and explore it's neighbours.</p> <p>Now, the exploration graph is as follows: </p> <p>Final distance array now looks like this:</p> <pre><code>Node     |  S   A   B   C   D \nDistance |  0  15  10  14  11\n</code></pre> <p>But now, since we have no green nodes, we stop. We have visited all the nodes.</p> <p>Couple of key points here. How were we SURE of the shortest distance of a green node? That node had the shortest distance among all the other green nodes.</p> <p>Now, summarizing Djikstra's algorithm:</p> <ol> <li>We keep a set of vertices for which final shortest distance is already known to us. Initially only the source vertex S belongs to this set.</li> <li>We do several iterations, during which we pick the green node with the minimum distance and add it to the set of vertices whose distances are finalized and also all nodes reaching from this node and not VISITED (i.e. NOT MARKED YELLOW), are made green.</li> </ol> <p>And that's it. That's the working of Djikstra's algorithm.</p> <p>Regarding the implementation, since we need the node with minimum distance, a min-heap is prefered. Implementations with sets( the ones based on BSTs) are also popular. You can find the implementations online with both the data structures.</p> <p>Now, for a moment, let's go back to where we started.</p> <p> At this point, we chose B. So, what we have done is finalized the distance to B and it can never be changed in coming iterations. Now, let's say that there was an edge from A to B with cost as -10 (Negative ten). The distance then is 15 + (-10) = 5, which is lower than 10.</p> <p>But, we had said that it can never be less than 10. Then, how come this?</p> <p>Here is the truth. Djikstra's algorithm doesn't work for negative edge weights.</p> <p>Let's think about the graphs involving negative weights cycles. If there is a negative weight cycle like the C-A-B-C below, we can keep moving in cycles and each iteration of the cycle will decrease the distance, so negative weight cycle is a big NO for Djikstra.  It's intuitive to understand that Djikstra doesn't work for negative cycles but not very intuitive to understand why it doesn't work for negative edges with no negative cycles.</p>"},{"location":"Advanced-1/#question-network-delay-time","title":"Question : Network Delay Time","text":"<p>You are given a network of  <code>n</code>  nodes, labeled from  <code>1</code>  to  <code>n</code>. You are also given  <code>times</code>, a list of travel times as directed edges  <code>times[i] = (ui, vi, wi)</code>, where  <code>ui</code>  is the source node,  <code>vi</code>  is the target node, and  <code>wi</code>  is the time it takes for a signal to travel from source to target.</p> <p>We will send a signal from a given node  <code>k</code>. Return  the  minimum  time it takes for all the <code>n</code> nodes to receive the signal. If it is impossible for all the  <code>n</code>  nodes to receive the signal, return  <code>-1</code>.</p> <p>Example 1:</p> <p></p> <p>Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</p> <p>Output: 2</p> <p>Example 2:</p> <p>Input: times = [[1,2,1]], n = 2, k = 1</p> <p>Output: 1</p> <p>Example 3:</p> <p>Input: times = [[1,2,1]], n = 2, k = 2</p> <p>Output: -1</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= k &lt;= n &lt;= 100</code></li> <li><code>1 &lt;= times.length &lt;= 6000</code></li> <li><code>times[i].length == 3</code></li> <li><code>1 &lt;= ui, vi &lt;= n</code></li> <li><code>ui != vi</code></li> <li><code>0 &lt;= wi &lt;= 100</code></li> <li>All the pairs  <code>(ui, vi)</code>  are  unique. (i.e., no multiple edges.)</li> </ul> <p>Solution: <pre><code>import heapq\nclass Solution:\n    def networkDelayTime(self, times, n, k):\n        #create adjacency list\n        adjList = {i:[] for i in range(1, n+1)} #Format of the adjacency list node: [neighbour, weight]\n        for src, dest, weight in times:\n            adjList[src].append([dest, weight])\n        #create minHeap\n        minHeap = []\n        minHeap.append([0, k]) #Minheap is of the structure distance, node; Initial is 0,k since k is starting node as written in question and its at 0 distance from itself\n        heapq.heapify(minHeap)\n        #dikjstra \n        dist = [float(\"inf\")] * (n+1) #Initial distance to all nodes is infinite\n        dist[k] = 0 #Distance to the starting node set to zero since it is the starting node itself\n        while minHeap: #Minheap to implement the jijkstras\n            dis, node = heapq.heappop(minHeap)\n            for it in adjList[node]:\n                edgeWeight = it[1]\n                edgeNode = it[0]\n                if (dis+edgeWeight) &lt; dist[edgeNode]: #Applying the formula to update the distance array\n                    dist[edgeNode] = dis+edgeWeight\n                    heapq.heappush(minHeap, [dist[edgeNode], edgeNode]) #Since the node is visited now, we add it to our heap\n        #result\n        return max(dist[1:]) if max(dist[1:]) != float(\"inf\") else -1 #Max of all the latency, else -1 if not possible\n\nSoln = Solution()\nprint(Soln.networkDelayTime([[2,1,1],[2,3,1],[3,4,1]], 4, 2))\n</code></pre> Description</p> <p> Visualization of traversing graph using Dijkstra algorithm and distance array. The priority queue itself is not shown there, as well as redundant nodes that we might have in priority queue. Green node - explored/current node, Yellow - node in the priority queue. Notes:</p> <ol> <li>We will have a set to track visited nodes.</li> <li>We will create a distance array to track the distance to each node. Initial node will have 0, others maximum. There is a room for optimization: if the node we got from the pq has larger cost than in our dist[] array, we should not explore it as we already got a better option.</li> <li>We will use min priority_queue to get the node with the minimum distance from the current node.</li> <li>If we are only interested in shortes distance till some END node, we can terminate the search earlier: if (node == dst) return cost;</li> <li>If we already find a better path we shouldn't explore it further: if (dist[node] &lt; stops) continue;</li> </ol>"},{"location":"Advanced-1/#extra-graph-algorithms","title":"Extra Graph Algorithms:","text":""},{"location":"Advanced-1/#union-find","title":"Union-Find:","text":"<p>Union\u2013find data structure or disjoint-set data structure or merge\u2013find set, is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a representative member of a set. Helps to find the number of connected components, and can help to find MST.</p> <pre><code>class UnionFind {\n    public:\n    UnionFind(int n) : parent(n) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int Find(int x) {\n        int temp = x;\n        while (temp != parent[temp]) {\n            temp = parent[temp];\n        }\n        // Path compression below\n        while (x != temp) {\n            int next = parent[x];\n            parent[x] = temp;\n            x = next;\n        }\n        return x;\n    }\n\n    void Union(int x, int y) {\n        int xx = Find(x);\n        int yy = Find(y);\n        if (xx != yy) {\n            parent[xx] = yy;\n        }\n    }\n\n    private:\n           vector&lt;int&gt; parent;\n};\n</code></pre> <p> The above picture demonstrates the state of the parent array after multiple Union() calls, follows multiple Find() calls. Notes: 1. We can use vector to hold the set of nodes or unordered_map if we don't know the amount of nodes. 2. If the parent[id] == id, we know that id is the root node. 3. The data structure using two methods Union() - union to nodes/components, and Find() - find the root node. 4. We can do path compression, so after some number of Find() calls it will be O(1) to call Find() again."},{"location":"Advanced-1/#minimum-spanning-tree-union-find","title":"Minimum Spanning Tree (Union Find):","text":"<p>A minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. Solution for Connecting Cities With Minimum Cost:  https://leetcode.com/problems/connecting-cities-with-minimum-cost/.</p> <pre><code>class UnionFind {\npublic:\n    UnionFind(int n) : parent(n) {\n          iota(parent.begin(), parent.end(), 0);\n    }\n    int Find(int x) {\n        int temp = x;\n        while (temp != parent[temp]) {\n            temp = parent[temp];\n        }\n        while (x != temp) {\n            int next = parent[x];\n            parent[x] = temp;\n            x = next;\n        }\n        return temp;\n    }\n    bool Union(int x, int y) {\n        int xx = Find(x);\n        int yy = Find(y);\n        if (xx == yy) return false;\n        parent[xx] = yy;\n        return true;\n    }\n\nprivate:\n    vector&lt;int&gt; parent;\n};\nint minimumCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {\n    sort(connections.begin(), connections.end(), [](const auto&amp; lhs, const auto&amp; rhs){\n        return lhs[2] &lt; rhs[2];\n    });\n    UnionFind uf(n + 1);\n    int sum = 0, count = 0;\n    for (auto&amp; c : connections) {\n        if (uf.Union(c[0], c[1])) {\n            count++;\n            sum += c[2];\n        }\n        if (count == n - 1) return sum; // Return earlier once graph is connected.\n    }\n    return -1;\n}\n</code></pre> <p> Visualization of Kruskal's algorithm: we will try to union nodes if they are not connected. Notes: 1. One of the implementation of MST algorithm use Union Find algorithm (Kruskal's Algorithm). 2. We need to sort elements by the weight before appying the algorithm, or we can use min priority_queue.</p>"},{"location":"Advanced-1/#topological-sort","title":"Topological sort:","text":"<p>Is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.</p> <pre><code>    // Kahn's Algorithm\n    vector&lt;vector&lt;int&gt;&gt; adj(numCourses);\n    vector&lt;int&gt; indegree(numCourses, 0);\n    for (auto&amp; p : prerequisites) {\n        indegree[p[1]]++;\n        adj[p[0]].push_back(p[1]);\n    }\n    queue&lt;int&gt; q;\n    for (int i = 0; i &lt; numCourses; i++) {\n        if (indegree[i] == 0) q.push(i);\n    }\n    int prereq = 0;\n    while (!q.empty()) {\n        int el = q.front();\n        q.pop();\n        prereq++;\n        for (auto&amp; next : adj[el]) {\n            if (--indegree[next] == 0) {\n                q.push(next);\n            }\n        }\n    }\n    return prereq == numCourses;\n</code></pre> <p> The above picture demonstrates linear order of the given graph. The vertices can be tasks, and edges can represent some contraints, such as U should be finished before V in (U -&gt; V). Notes: 1. We will have the indegree array to count, which nods should be visited first. 2. We will have a queue to push the nodes that don't have any dependencies.</p>"},{"location":"Advanced-1/#bellman-ford","title":"Bellman Ford:","text":"<p>Is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph.</p> <pre><code>class Solution {\npublic:\n    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        dist[k] = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            for (auto&amp; t : times) {\n                if (dist[t[0]] != INT_MAX &amp;&amp; dist[t[1]] &gt; dist[t[0]] + t[2]) {\n                    dist[t[1]] = dist[t[0]] + t[2];\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            res = max(res, dist[i]);\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n};\n</code></pre> <p> The above picture demonstrates how the dist array incrementally updated with better values. If not a single value is updated during iteration - we can stop earlier. Notes: 1. We will use the array to hold the distance between particular start node and all others. 2. We will try to improve distance n times between all nodes in the graph.</p>"},{"location":"Advanced-1/#floyd-warshall","title":"Floyd Warshall:","text":"<p>Is an algorithm for finding shortest paths in a directed weighted graph with positive or negative edge weights.</p> <pre><code>class Solution {\npublic:\n    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;vector&lt;long&gt;&gt; dist(n, vector&lt;long&gt;(n, INT_MAX));\n        for (auto&amp; t : times)\n            dist[t[0] - 1][t[1] - 1] = t[2];\n        for (int i = 0; i &lt; n; i++)\n            dist[i][i] = 0;\n        for (int k = 0; k &lt; n; k++) {\n            for (int i = 0; i &lt; n; i++) {\n                for (int j = 0; j &lt; n; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        long res = INT_MIN;\n        for (int i = 0; i &lt; n; i++) {\n            if (dist[k - 1][i] == INT_MAX) return -1;\n            res = max(res, dist[k - 1][i]);\n        }\n        return (int)res;\n    }\n};\n</code></pre> <p>Vizualization for Floyd Warshall is slightly different from Bellman Ford, but the idea stays the same. Notes: 1. We will use vector to keep track of distance between nodes i and j. 2. We will have a 3 loops, checks if we can improve the distance between i and j by using k node."},{"location":"Advanced-1/#eulearian-path","title":"Eulearian Path:","text":"<p>Is an algorithm that finds a path that uses every  edge  in a graph only once. The algorithm below is a solution for the \"Reconstruct Itinerary\":  https://leetcode.com/problems/reconstruct-itinerary/</p> <pre><code>class Solution {\npublic:\n    void dfs(unordered_map&lt;string, multiset&lt;string&gt;&gt;&amp; graph,\n             vector&lt;string&gt;&amp; res, string start) {\n        while (graph[start].size() &gt; 0) {\n            auto next = *graph[start].begin();\n            graph[start].erase(graph[start].begin());\n            dfs(graph, res, next);\n        }\n        res.push_back(start);\n    }\n    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) {\n        unordered_map&lt;string, multiset&lt;string&gt;&gt; graph;\n        for (const auto&amp; t : tickets) graph[t[0]].insert(t[1]);\n        vector&lt;string&gt; res;\n        dfs(graph, res, \"JFK\");\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n</code></pre> <p> The above picture is the visualization of eulerian path algorithm. You can observe how the result is constructed on the backtracking. Notes: 1. The algorithm almost identical to the dfs traversal with one main instrumentation: we are building the path on the backtrack of the dfs algorithm:  <code>res.push_back(start);</code> 2. That is why we should reverse the list at the end of the traversal:  <code>reverse(res.begin(), res.end());</code> 3. In the above implementation we are using multiset (because of the problem), but the general implementation may use vector&lt;&gt; and additional vector&lt;&gt; to track the outgoing degrees, and use it for two main purposes: as index in the adj list, and to track how many node we not visited yet.</p>"},{"location":"Advanced-2/","title":"ACM Foundations - Linked Lists, Stacks and Queues","text":""},{"location":"Advanced-2/#1-linked-lists","title":"1. Linked Lists","text":""},{"location":"Advanced-2/#11-why-use-linked-lists","title":"1.1 Why use Linked Lists?","text":"<p>Let us assume you are making a website and you need to record the names of customers who log in on the site. What size array would you use to store the data? If you select too small a size, then you will run out of space in the array. If you select a size too large you will be wasting space as much of it will be unused. It would be a lot more convenient if we could create a data-structure that could increase or decrease in size depending on how much data you wish to store in it. That is exactly what linked lists are designed for.</p>"},{"location":"Advanced-2/#12-how-do-linked-lists-work","title":"1.2 How do Linked Lists Work?","text":"<p>A linked list is made up of nodes, each node is a variable that keeps track of two values : 1. The value of the element in that node 2. A pointer to the next node in the list (NULL if it is the last node in the list)</p> <p>The first node of the list is stored in a variable, generally termed 'head' or 'root'.     </p>"},{"location":"Advanced-2/#13-linked-list-implementation-python-3x","title":"1.3 Linked List Implementation (Python 3.x)","text":"<p>First we need a node that can hold a value and the next node in the chain.</p> <pre><code>class Node:\n    def __init__(self, value = None):\n        self.value = value\n        self.next_ptr = None\n</code></pre> <p>Now let us make a simple class where we can add new elements to the list. <pre><code>class LinkedList:\n    def __init__(self):\n        self.root = None # no node when we create the list\n        self.size = 0\n\n    def insert_value(self, value):\n        if self.root == None:\n            self.root = Node(value)\n            self.size += 1\n            return\n\n        curr_node = self.root\n        while curr_node.next_ptr is not None:\n            curr_node = curr_node.next_ptr\n\n        curr_node.next_ptr = Node(value)\n        self.size += 1\n</code></pre></p> <p>We can use this class to store email addresses of people who join the site as they come. This code will also print the number of elements in the list after it is created. <pre><code>emails = LinkedList()\n\nwhile True:\n    email_id = input(\"Enter an email id: \")\n    if email_id == \"\":\n        break\n\n    emails.insert_value(email_id)\n\nprint(\"Number of email ids in the list:\", emails.size)\n</code></pre></p> <p>If we want to print the elements in the list, we can copy the root and iterate over the list till we hit a null value. <pre><code>curr_node = emails.root\n\nwhile curr_node is not None:\n    print(curr_node.value)\n    curr_node = curr_node.next_ptr\n</code></pre></p>"},{"location":"Advanced-2/#14-problem-number-to-linked-list","title":"1.4 Problem : Number to Linked List","text":"<p>Take an integer as input and convert it to a linked list where each node is a digit of the number.</p> <p>Note that if you try to simply insert the values into the list the number will end up reversed like this :  <pre><code>number = int(input(\"Enter a number: \"))\n\nll = LinkedList()\n\nwhile number != 0:\n    digit = number % 10\n\n    ll.insert_value(digit)\n\n    number = int(number / 10)\n\ncurr_node = ll.root\n\nwhile curr_node is not None:\n    print(curr_node.value, end = \" -&gt; \")\n    curr_node = curr_node.next_ptr\n</code></pre></p> <p>So to solve this issue we have two approaches :  1. We create a function to insert an element at the start of a list rather than the end. 2. We reverse the list after creating it.</p> <p>To implement code to add new elements to the start of the list, we can do something like this <pre><code>class LinkedList:\n    def __init__(self):\n        self.root = None # no node when we create the list\n        self.size = 0\n\n    def insert_value(self, value):\n        if self.root == None:\n            self.root = Node(value)\n            self.size += 1\n            return\n\n        curr_node = self.root\n        while curr_node.next_ptr is not None:\n            curr_node = curr_node.next_ptr\n\n        curr_node.next_ptr = Node(value)\n        self.size += 1\n\n    def insert_start(self, value):\n        prev_root = self.root\n\n        new_root = Node(value)\n        new_root.next_ptr = prev_root\n\n        self.root = new_root\n\nnumber = int(input(\"Enter a number: \"))\n\nll = LinkedList()\n\nwhile number != 0:\n    digit = number % 10\n\n    ll.insert_start(digit)\n\n    number = int(number / 10)\n\ncurr_node = ll.root\n\nwhile curr_node is not None:\n    print(curr_node.value, end = \" -&gt; \")\n    curr_node = curr_node.next_ptr\n</code></pre></p>"},{"location":"Advanced-2/#15-try-it-yourself","title":"1.5 Try it Yourself","text":"<p>Try writing the code to reverse the linked-list by yourself.</p>"},{"location":"Advanced-2/#2-stacks","title":"2. Stacks","text":""},{"location":"Advanced-2/#21-what-are-stacks","title":"2.1 What are Stacks?","text":"<p>Stacks are a data structure in which elements are inserted one after the other, and the most recent elements are removed first. For example, if we need to make a system where we analyze news articles and need to read the latest articles first before we look at old ones, stacks are perfect for this problem.</p> <p></p> <p>A stack has two main operations that we need to perform :  1. Push : Adds a value to the stack 2. Pop : Removes a value from the stack</p> <p>Other common operations are : 1. Top : Returns the value at the top of the stack 2. Size : Returns the number of elements in the stack 3. IsEmpty : True if the stack is empty</p>"},{"location":"Advanced-2/#22-stack-implementation-python-3x","title":"2.2 Stack Implementation (Python 3.x)","text":"<pre><code>class Stack:\n    def __init__(self):\n        self.root = None # no node when we create the list\n        self.size = 0\n\n    def push(self, value):\n        '''\n        Adds a value to the top of the stack.\n        '''\n        if self.root == None:\n            self.root = Node(value)\n            self.size += 1\n            return\n\n        curr_node = self.root\n        while curr_node.next_ptr is not None:\n            curr_node = curr_node.next_ptr\n\n        curr_node.next_ptr = Node(value)\n        self.size += 1\n\n    def pop(self):\n        '''\n        Removes a value from the top of the stack\n        '''\n\n        if self.root == None:\n          return None\n\n        elif self.size == 1:\n          val = self.root.value\n          self.root = None\n          self.size = 0\n          return val\n\n        curr_node = self.root\n        # loop to find the 2nd last element in the stack and put it in curr_node\n        while curr_node.next_ptr.next_ptr is not None:\n            curr_node = curr_node.next_ptr\n\n        val = curr_node.next_ptr.value # val = last element in the stack\n        curr_node.next_ptr = None # delete the last element\n        self.size -= 1\n        return val\n\n    def top(self):\n        '''\n        Returns the value from the top of the stack\n        '''\n\n        if self.root == None:\n          return None\n\n        elif self.size == 1:\n          val = self.root.value\n          return val\n\n        curr_node = self.root\n        # loop to find the 2nd last element in the stack and put it in curr_node\n        while curr_node.next_ptr.next_ptr is not None:\n            curr_node = curr_node.next_ptr\n\n        val = curr_node.next_ptr.value # val = last element in the stack\n        return val\n\n    def isEmpty(self):\n        '''\n        True if the stack is empty. False otherwise.\n        '''\n        return self.size == 0\n</code></pre>"},{"location":"Advanced-2/#23-problem-valid-brackets","title":"2.3 Problem : Valid Brackets","text":"<p>Write a program to check if a series of brackets are valid.  Ex.  1. [()()] is valid 2. [} is invalid 3. [(] is invalid</p> <pre><code>string = input(\"Enter the brackets: \")\n\n\ndef isValidBrackets(string):\n    stack = Stack()\n\n    for char in string:\n        if char == '(' or char == '{' or char == '[':\n            stack.push(char)\n        elif char == ')':\n            val = stack.pop()\n\n            if val == '(': # correct opening bracket for this closing bracket\n                continue\n            else:\n                return False\n        elif char == ']':\n            val = stack.pop()\n\n            if val == '[': # correct opening bracket for this closing bracket\n                continue\n            else:\n                return False\n        elif char == '}':\n            val = stack.pop()\n\n            if val == '{': # correct opening bracket for this closing bracket\n                continue\n            else:\n                return False\n\n    if stack.isEmpty(): # no remaining open brackets should be left in the stack\n        return True\n    else:\n        return False\n\n\nif isValidBrackets(string):\n    print(\"Valid brackets.\")\nelse:\n    print(\"Invalid brackets.\")\n</code></pre>"},{"location":"Advanced-2/#3-leetcode","title":"3. Leetcode","text":""},{"location":"Advanced-2/#31-introduction-to-leetcode","title":"3.1 Introduction to Leetcode","text":"<p>Leetcode is currently the largest online platform where you can learn and practice coding interview style questions. These types of questions are largely based on data structures and algorithms and are also commonly seen in competitive programming contests.</p>"},{"location":"Advanced-2/#32-your-first-problem","title":"3.2 Your First Problem","text":"<p>Let us try leetcode out with the above stack problem. Valid Parentheses is an easy leetcode problem. Try pasting your solution to the problem from the code above and see the results! Keep in mind that as this code is not optimized, the execution speed will not be competitive. Try re-writing the code using native python lists to improve performance.</p>"},{"location":"Advanced-2/#33-asteroid-collision","title":"3.3 Asteroid Collision","text":"<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p> <p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p> <p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p> <p>Example 1:</p> <p>Input: asteroids = [5,10,-5] Output: [5,10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.</p> <p>Example 2:</p> <p>Input: asteroids = [8,-8] Output: [] Explanation: The 8 and -8 collide exploding each other.</p> <p>Example 3:</p> <p>Input: asteroids = [10,2,-5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.</p> <p>Constraints:</p> <ul> <li><code>2 &lt;= asteroids.length &lt;= 104</code></li> <li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li> <li><code>asteroids[i] != 0</code></li> </ul> <p>Explaination:</p> <p>Collision will only take place when the upcoming asteroid will be moving toward left and the prev asteroid is moving toward right otherwise collsion will not take place because they will not meet.</p> <p></p> <p>Hence we need to first check the condition wheter they are colliding or not. If the collision happens, then:</p> <p>a) If the current asteroid is smaller than the one we saw earlier, it will explode, and the collision chain will stop there. </p> <p>b) if the current asteroid bigger, it will keep moving toward the left and might collide further with other asteroids we saw earlier that are moving toward the right. </p> <p>c) If the current asteroid is the same size as the one we saw earlier, both of them will explode and the collision chain will stop sinct the current stone is destroyed</p> <p>Hence, the observation here is that each stone might keep colliding with asteroids on its left until it collides with a bigger asteroid or an asteroid of same size and explodes.</p> <p>This requirement could be fulfilled by the stack data structure; if we keep asteroids in the stack, then for each asteroid, the collision chain can be executed by checking the top of the stack and popping if an asteroid should be destroyed.*</p> <p>The link for this question can be found here.</p> <p>Solution:</p> <pre><code>class Solution:\n    def collision_check(self, m, n):\n        if m &gt; 0 and n &lt; 0:\n            return True\n        else:\n            return False\n\n    def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:\n        final_asteroid = []\n        for x in asteroids:\n            asteroid_destroyed = False\n            if not final_asteroid or not self.collision_check(final_asteroid[-1], x):\n                final_asteroid.append(x)\n            else:\n                while final_asteroid and self.collision_check(final_asteroid[-1], x) and abs(final_asteroid[-1]) &lt;= abs(x):\n                    if abs(final_asteroid[-1]) == abs(x):\n                        asteroid_destroyed = True\n                        final_asteroid.pop()\n                        break\n                    final_asteroid.pop()\n                if not asteroid_destroyed and (not final_asteroid or (final_asteroid and not self.collision_check(final_asteroid[-1], x))):\n                    final_asteroid.append(x)\n\n        return final_asteroid\n</code></pre>"},{"location":"Advanced-2/#4-queues","title":"4. Queues","text":""},{"location":"Advanced-2/#41-what-are-queues","title":"4.1 What are Queues","text":"<p>A queue is a linear data structure in which insertions are done at one end (rear) and deletions are done at the other end (front). The first element to be inserted is the first one to be deleted. Hence, it's called as a First In First Out (FIFO) list.</p> <p>A Queue is like a line waiting to purchase tickets, where the first person in line is the first person served. (i.e. First come first serve).</p> <p></p> <p>The queue has two pointers, Front and Rear. The front points towards the first element while the rear points towards the last element of the queue.</p>"},{"location":"Advanced-2/#42-queue-operations","title":"4.2 Queue Operations","text":"<ol> <li> <p><code>enQueue(int data)</code> :Inserts and element at the end of the queue. This operation adds a new node after the rear and moves the rear pointer to the new node added.</p> </li> <li> <p><code>deQueue()</code>: Removes and returns the elemnt at the front of the queue.This operation removes the front node and moves the front pointer to the next node.</p> </li> <li> <p><code>isEmpty()</code>: Indicates whether no elements are stored.</p> </li> <li> <p><code>front()</code>: Returns the element at the front withput removing it from the queue.</p> </li> <li> <p><code>QueueSize()</code>: Returns the number of elements stored in the queue.</p> </li> </ol>"},{"location":"Advanced-2/#43-implementation-of-queue-using-linked-list-python-3x","title":"4.3 Implementation of Queue using Linked List (Python 3.x)","text":"<p>First we'll define a class <code>Node</code> - A linked list node to store queue entry</p> <pre><code>class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n</code></pre> <p></p> <p>Then we define a class <code>Queue</code>. Its constructor will have 2 pointer: Front and Rear. Initially, since the queue is empty, Both of them point at <code>None</code></p> <pre><code>class Queue:\n\n    def __init__(self):\n        self.front = self.rear = None\n</code></pre> <p></p> <p>Defining EnQueue(item)</p> <pre><code>def EnQueue(self, item):\n        temp = Node(item)\n\n        if self.rear == None:\n            self.front = self.rear = temp\n            return\n        self.rear.next = temp\n        self.rear = temp\n</code></pre> <p>Case (a): When the Queue is initially empty</p> <p></p> <p>Case (b): When the Queue has some elements</p> <p></p> <p>Defining DeQueue():</p> <pre><code>  def DeQueue(self):\n\n        if self.isEmpty():\n            return\n        temp = self.front\n        self.front = temp.next\n\n        if(self.front == None):\n            self.rear = None\n</code></pre> <p></p> <p>Defining isEmpty ():</p> <pre><code>    def isEmpty(self):\n        return self.front == None\n</code></pre> <p>Defining front():</p> <pre><code>def front(self):\n    return self.front\n</code></pre>"},{"location":"Advanced-2/#44-leetcode-question-flatten-nested-list-iterator","title":"4.4 Leetcode Question: Flatten Nested List Iterator","text":"<p>Description: You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. You can find the leetcode question here.</p> <p>Implement the <code>NestedIterator</code> class:</p> <ul> <li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li> <li><code>int next()</code> Returns the next integer in the nested list.</li> <li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li> </ul> <p>Your code will be tested with the following pseudocode:</p> <pre><code>initialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n append iterator.next() to the end of res\nreturn res\n</code></pre> <p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p> <p>Example 1:</p> <p>Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p> <p>Example 2:</p> <p>Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nestedList.length &lt;= 500</code></li> <li>The values of the integers in the nested list is in the range <code>[-106, 106]</code>.</li> </ul> <p>Assumptions:</p> <p>The question has already defines a NestedInteger class with the functions <code>isInteger()</code> , <code>getInteger()</code> and <code>getList()</code>.</p> <p>We have to implement the NestedIterator class.</p> <pre><code># This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# class NestedInteger(object):\n#    def isInteger(self):\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#    def getInteger(self):\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#    def getList(self):\n#       return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n\nclass NestedIterator(object):\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())\n</code></pre> <p>Solution:</p> <p>Basically, if you find an integer, add it to the queue or else if you find a nested list, use the function recursively to search for integers in that particular nested list and hence add it to the final queue.</p> <p>Code:</p> <pre><code>import queue\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        self.flattenedList= queue.Queue()\n        self.flatten(nestedList)\n\n    def flatten(self , nestedList):\n        for x in nestedList:\n            if x.isInteger():\n                self.flattenedList.put(x.getInteger()) \n            else:\n                self.flatten(x.getList())   \n\n    def next(self):\n        return self.flattenedList.get()\n\n    def hasNext(self):\n        return not(self.flattenedList.empty())\n</code></pre>"},{"location":"Advanced-3/","title":"ACM Foundations - Hash Sets and Hash Maps","text":""},{"location":"Advanced-3/#1-hash-sets","title":"1. Hash Sets","text":""},{"location":"Advanced-3/#11-what-are-hash-sets","title":"1.1 What are hash sets?","text":"<p>Imagine you are making a website with millions of users. Whenever a user wishes to login in to the site you will need to check if his username is in the database and then check if his password matches the one for his account. But if we have so many users then checking an array or a list with all users for this username will be very time consuming. Hash sets are a data structure that allow you to lookup a value in a very short amount of time regardless of how many elements there are.</p>"},{"location":"Advanced-3/#12-problem-statement","title":"1.2 Problem Statement","text":"<p>Let us tackle a simple version of this problem first. Can we make a program that can tell you if an element is in an array that takes a constant amout of time to run regardless of the array's size? </p>"},{"location":"Advanced-3/#13-basic-solution","title":"1.3 Basic Solution","text":"<p>Well, let us first think of what operations will take the same amount of time to run regardless of the input size : 1. Arithmetic Operations (+, -, *, /, %) 2. Indexing Elements in an Array (arr[i]) 3. Logical Expressions (&lt;, &gt;, ==, !=) 4. If-Else Conditions</p> <p>What if we try writing a program where we have a function ind(x) that returns the expected location of an element in an array? Then this function could take as input an element x, check if the element is present at that index in the array. The way we do this is to create an array of booleans and set the value at that index to True if the element is present. Also we will name the function that returns indices our hash_function.</p> <p>Let us look at a simple code for a hash set that stores elements between 0 and 9.</p> <pre><code>def hash_function(x, arr_size):\n    index = x % arr_size\n\n    return index\n\narr_size = 10\n\nhash_set = [False] * arr_size\n\ninput_elements = [1, 2, 5, 8]\n\nfor ele in input_elements:\n    ind = hash_function(ele, arr_size)\n\n    hash_set[ind] = True\n\n\n# User input\nwhile True:\n    new_element = int(input(\"Enter a number between 0 and 9 : \"))\n\n    if new_element == -1:\n        break\n\n    ind = hash_function(new_element, arr_size)\n\n    if hash_set[ind] == True:\n        print(\"Element is present in the set.\")\n    else:\n        print(\"Element is not present in the set.\")\n</code></pre>"},{"location":"Advanced-3/#14-expanding-hash-sets","title":"1.4 Expanding Hash Sets","text":"<p>What if we have an almost infinite input scope (like usernames)? Then we will have collisions where many elements are all mapped to the same index. To accommodate this, we will create an array of linked-lists and to store an element we will insert it into the linked list at that position. Keep in mind that this is still much faster than using a single linked list to store all our values.</p> <p></p> <p>Let us now make a hash set to store any positive integer.</p> <pre><code>def hash_function(x, arr_size):\n    index = x % arr_size\n\n    return index\n\ndef insert_ele(hash_set, ele, arr_size):\n    index = hash_function(ele, arr_size)\n\n    hash_set[index].append(ele)\n\ndef is_present(hash_set, ele, arr_size):\n    index = hash_function(ele, arr_size)\n\n    linked_list = hash_set[index]\n\n    for i in range(len(linked_list)):      \n        if linked_list[i] == ele:\n          return True\n\n    return False\n\narr_size = 100\n\nhash_set = [[].copy() for i in range(arr_size)]\n\ninput_elements = [50, 90, 1000, 2000]\n\nfor ele in input_elements:\n    insert_ele(hash_set, ele, arr_size)\n\n\n# User input\nwhile True:\n    new_element = int(input(\"Enter a number: \"))\n\n    if new_element == -1:\n        break\n\n    if is_present(hash_set, new_element, arr_size):\n        print(\"Element is present in the set.\")\n    else:\n        print(\"Element is not present in the set.\")\n</code></pre>"},{"location":"Advanced-3/#14-efficient-python-implementation","title":"1.4 Efficient Python Implementation","text":"<p>To use hash sets efficiently in python, there is the built-in set datatype. Let us see the speed increase of this class over a python list. </p> <pre><code>import time\n\nlimit = 10 ** 7\n\nnums = range(limit)\n\nlst = list(nums)\nhash_set = set(nums)\n\nstart = time.time()\nprint(limit in lst)\nprint(\"The list took {} seconds to search though the whole list.\".format(time.time() - start))\n\nstart = time.time()\nprint(limit in hash_set)\nprint(\"The set took {} seconds to search though the whole list.\".format(time.time() - start))\n</code></pre>"},{"location":"Advanced-3/#2-hash-map","title":"2. Hash Map","text":""},{"location":"Advanced-3/#21-extending-hash-sets","title":"2.1 Extending Hash Sets","text":"<p>A hash set can only be used to find if an element is in an array. What if we need to find some associated value for that element? For example, in a website we will need to link the username to a password. This is where hashmaps come in, these are called mappings as they map some input to a fixed value.</p> <p></p> <p>We can do this by making each entry in the linked-lists hold two values, the first value will be the key and the second one will be the data we are storing. Let us look at an example with user ids and passwords.</p> <pre><code>def hash_function(usr_id, arr_size):\n    index = usr_id % arr_size\n\n    return index\n\ndef insert_usr(hash_map, usr_id, password, arr_size):\n    index = hash_function(usr_id, arr_size)\n\n    hash_map[index].append((usr_id, password))\n\ndef is_usr_present(hash_map, usr_id, arr_size):\n    index = hash_function(usr_id, arr_size)\n\n    linked_list = hash_map[index]\n\n    for i in range(len(linked_list)):      \n        if linked_list[i][0] == usr_id: # index 0 is the user_id in a list entry\n          return True\n\n    return False\n\ndef get_password(hash_map, usr_id, arr_size):\n    index = hash_function(usr_id, arr_size)\n\n    linked_list = hash_map[index]\n\n    for i in range(len(linked_list)):      \n        if linked_list[i][0] == usr_id: # index 0 is the user_id in a list entry\n          return linked_list[i][1] # password for that user\n\n    return None\n\narr_size = 100\n\nhash_map = [[].copy() for i in range(arr_size)]\n\ninput_users = [(12, \"pass\"), (10, \"abcd\"), (10016, \"12345\"), (190903, \"adJn%^0\")]\n\nfor info in input_users:\n    usr_id, password = info\n    insert_usr(hash_map, usr_id, password, arr_size)\n\n# User input\nwhile True:\n    new_user = int(input(\"Enter a user ID: \"))\n\n    if new_user == -1:\n        break\n\n    if is_usr_present(hash_map, new_user, arr_size) == False:\n        print(\"This user is not present in the database.\")\n        continue\n\n    stored_pass = get_password(hash_map, new_user, arr_size)\n\n    entered_pass = input(\"Enter the password: \")\n\n    if stored_pass == entered_pass:\n        print(\"User authenticated!\")\n    else:\n      print(\"Invalid password. Access denied.\")\n</code></pre>"},{"location":"Advanced-3/#22-efficient-python-implementation","title":"2.2 Efficient Python Implementation","text":"<p>Much like hash sets, python has an in-built class for hash maps called dictionaries. Let us re-write the above code using them.</p> <pre><code>hash_map = dict()\n\ninput_users = [(12, \"pass\"), (10, \"abcd\"), (10016, \"12345\"), (190903, \"adJn%^0\")]\n\nfor info in input_users:\n    usr_id, password = info\n    hash_map[usr_id] = password\n\n# User input\nwhile True:\n    new_user = int(input(\"Enter a user ID: \"))\n\n    if new_user == -1:\n        break\n\n    user_is_present = (new_user in hash_map)\n\n    if user_is_present == False:\n        print(\"This user is not present in the database.\")\n        continue\n\n    stored_pass = hash_map[new_user]\n\n    entered_pass = input(\"Enter the password: \")\n\n    if stored_pass == entered_pass:\n        print(\"User authenticated!\")\n    else:\n      print(\"Invalid password. Access denied.\")\n</code></pre>"},{"location":"Advanced-3/#3-leetcode-problems","title":"3. Leetcode Problems","text":""},{"location":"Advanced-3/#31-easy-problem","title":"3.1 Easy Problem","text":"<p>2283. Check if Number Has Equal Digit Count and Digit Value</p> <p>(Easy)</p> <p>You are given a 0-indexed string <code>num</code> of length <code>n</code> consisting of digits.</p> <p>Return <code>true</code> if for every index <code>i</code> in the range <code>0 &lt;= i &lt; n</code>, the digit <code>i</code> occurs <code>num[i]</code> times in <code>num</code>, otherwise return <code>false</code>.</p> <p>Example 1:</p> <p>Input: num = \"1210\" Output: true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true.</p> <p>Example 2:</p> <p>Input: num = \"030\" Output: false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false.</p> <p>Constraints:</p> <ul> <li><code>n == num.length</code></li> <li><code>1 &lt;= n &lt;= 10</code></li> <li><code>num</code> consists of digits.</li> </ul> <p>Logic</p> <p>Here we have to note down a few things:</p> <ol> <li> <p>The keys of the hashmap are 0- length of the string \"num\"</p> </li> <li> <p>the occurence of each key is checked in the number. Accordingly the value to the Key is assigned.</p> </li> </ol> <p>E.g: For the number \"1210\"</p> <p>num[0] = '1'. The digit 0 occurs once in num.    num[1] = '2'. The digit 1 occurs twice in num.    num[2] = '1'. The digit 2 occurs once in num.    num[3] = '0'. The digit 3 occurs zero times in num.    The condition holds true for every index in \"1210\", so return true.</p> <ol> <li>To get the result \"True\": value assigned to each key in hashmap , should match the digit at the key index in number. e.g  for the number \"1210\"</li> </ol> <p>Hash Map </p> Key Values Number Digit 0 1 num[0] 1 1 2 num[1] 2 2 1 num[2] 1 3 0 num[3] 0 <ol> <li>The \"0\"s in the beginning of the number are counted e.g- the number \"030\" has 2 zeros</li> </ol> <p>code:</p> <pre><code>class Solution(object):\n    def digitCount(self, num):\n        record_check = {}\n\n        original_number = [0] * len(num)\n\n        for i in range(len(num)):\n            record_check[i] = 0\n\n        for i in range(len(num)):\n            ch = int(num[i])\n            original_number[i] = ch\n            if ch in record_check:\n                count = record_check[ch]\n                record_check[ch] = count + 1\n\n        for i in range(len(num)):\n            if original_number[i] != record_check[i]:\n                    return False\n\n        return True\n</code></pre>"},{"location":"Advanced-3/#32-medium-problem","title":"3.2 Medium problem","text":"<p>1930. Unique Length-3 Palindromic Subsequences</p> <p>(Medium)</p> <p>Given a string <code>s</code>, return the number of unique palindromes of length three that are a subsequence of <code>s</code>.</p> <p>Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.</p> <p>A palindrome is a string that reads the same forwards and backwards.</p> <p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p> <ul> <li>For example, <code>\"ace\"</code> is a subsequence of <code>\"&lt;u&gt;a&lt;/u&gt;b&lt;u&gt;c&lt;/u&gt;d&lt;u&gt;e&lt;/u&gt;\"</code>.</li> </ul> <p>Example 1:</p> <p>Input: s = \"aabca\" Output: 3 Explanation: The 3 palindromic subsequences of length 3 are:</p> <ul> <li>\"aba\" (subsequence of \"aabca\")</li> <li>\"aaa\" (subsequence of \"aabca\")</li> <li>\"aca\" (subsequence of \"aabca\")</li> </ul> <p>Example 2:</p> <p>Input: s = \"adc\" Output: 0 Explanation: There are no palindromic subsequences of length 3 in \"adc\".</p> <p>Example 3:</p> <p>Input: s = \"bbcbaba\" Output: 4 Explanation: The 4 palindromic subsequences of length 3 are:</p> <ul> <li>\"bbb\" (subsequence of \"bbcbaba\")</li> <li>\"bcb\" (subsequence of \"bbcbaba\")</li> <li>\"bab\" (subsequence of \"bbcbaba\")</li> <li>\"aba\" (subsequence of \"bbcbaba\")</li> </ul> <p>Constraints:</p> <ul> <li><code>3 &lt;= s.length &lt;= 105</code></li> <li><code>s</code> consists of only lowercase English letters.</li> </ul> <p>Logic:</p> <p>Let's take the string \"bbcbaba\"\"</p> <p>We need 3 values:</p> <p>1. First occurence of a character: The first index position of the character </p> <p>2. Last occurence of a character: The last index postition of the character. If the character occurse only once, then the first index and last index of the character is same.</p> <p>To keep track of characters and their index values, we use HashMaps since the character {keys} should be unique and their index position {value} should be stored with respect to the particular character</p> <p>NOTE: Since this is a key, value pair, we use the dictionary datatype in python.</p> <p>3. Unique Characters: The number of characters present in between the first and the last index. </p> <p>Note: the character must be unique, since palindromes of repeated letters would be counted as one.</p> <p>E.g: \"bbb\" formed by \"b\"s at 0th,1st and 5th index is the same as \"bbb\" formed by \"b\"s at 0th,2nd and 5th index.</p> <p>Hence to maintain the uniqueness of characters we use HashSet</p> <p>NOTE: To maintain the uniqueness we use the Set datatype in python.</p> Character First Occurrence Last Occurrence Unique Characters Count (t) Palindromes Count (a) 'a' 4 6 1{b} 1 'b' 0 5 3{a,b,c} 3 'c' 2 2 0 0 <p>code:</p> <pre><code>class Solution(object):\n    def countPalindromicSubsequence(self, s):\n        total_palindromes = 0\n        ch = list(s)\n        first_occurrence = {}\n        last_occurrence = {}\n\n        for i, value in enumerate(ch):\n            if value in first_occurrence:\n                last_occurrence[value] = i\n            else:\n                first_occurrence[value] = i\n                last_occurrence[value] = i\n\n        for key in first_occurrence.keys():\n                start = first_occurrence[key]\n                end = last_occurrence[key]\n\n                if end - start &gt; 1:\n                    between = set(ch[start+1:end])\n                    total_palindromes += len(between)            \n        return total_palindromes\n</code></pre>"},{"location":"Advanced-4/","title":"Advanced Session: 4","text":""},{"location":"Advanced-4/#recursion-and-dynamic-programming","title":"Recursion and Dynamic Programming","text":""},{"location":"Advanced-4/#recursion","title":"Recursion","text":"<p>Recursion is like a funhouse mirror, creating a seemingly endless loop of self-referential code. It's a powerful technique that allows functions to call themselves, leading to a series of nested steps that solve complex problems in an elegant way.</p> <p>Eg 1: counting down from a given number. Instead of writing a loop, you could use recursion to create a function that calls itself, decreasing the number by one each time until it reaches zero.</p> <pre><code>    def countdown(n):\n        if n == 0:\n            print(\"Blast off!\")\n        else:\n            print(n)\n            countdown(n - 1)\n</code></pre> <p>Eg 2: Factorial calculation (Factorial is the product of all positive integers from 1 to a given number)</p> <pre><code>    def factorial(n):\n        if n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n</code></pre> <p>Recursion has both it's pros and cons, as listed below. Advantages of recursion  * Elegant and Concise * Modularity and Reusability * Ease of Implementation</p> <p>Drawbacks of recursion</p> <p>Recursion uses memory space less efficiently. Repeated function calls create entries for all the variables and constants in the function stack. As the values are kept there until the function returns, there is always a limited amount of stack space in the system, thus making less efficient use of memory space. Additionally, a stack overflow error occurs if the recursive function requires more memory than is available in the stack.</p> <p>Recursion is also relatively slow in comparison to iteration, which uses loops. When a function is called, there is an overhead of allocating space for the function and all its data in the function stack in recursion. This causes a slight delay in recursive functions.</p>"},{"location":"Advanced-4/#dynamic-programming","title":"Dynamic Programming?","text":"<p>Dynamic programming is a computer programming technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution \u2014 which usually has to do with finding the maximum and minimum range of the algorithmic query.</p>"},{"location":"Advanced-4/#recursion-vs-dynamic-programming","title":"Recursion vs. dynamic programming","text":"<p>In computer science, recursion is a crucial concept in which the solution to a problem depends on solutions to its smaller subproblems.</p> <p>Meanwhile, dynamic programming is an optimization technique for recursive solutions. It is the preferred technique for solving recursive functions that make repeated calls to the same inputs. A function is known as recursive if it calls itself during execution. This process can repeat itself several times before the solution is computed and can repeat forever if it lacks a base case to enable it to fulfill its computation and stop the execution.</p> <p>However, not all problems that use recursion can be solved by dynamic programming. Unless solutions to the subproblems overlap, a recursion solution can only be arrived at using a divide-and-conquer method.</p> <p>For example, problems like merge, sort, and quick sort are not considered dynamic programming problems. This is because they involve putting together the best answers to subproblems that don\u2019t overlap.</p>"},{"location":"Advanced-4/#leetcode-question","title":"Leetcode Question","text":"<p>Problem Link</p> <p>There is a robot on an  <code>m x n</code>  grid. The robot is initially located at the  top-left corner  (i.e.,  <code>grid[0][0]</code>). The robot tries to move to the  bottom-right corner  (i.e.,  <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>Given the two integers  <code>m</code>  and  <code>n</code>, return  the number of possible unique paths that the robot can take to reach the bottom-right corner.</p> <p>The test cases are generated so that the answer will be less than or equal to  <code>2 * 109</code>.</p> <p>Example 1:</p> <p></p> <p>Input: m = 3, n = 7 Output: 28</p> <p>Example 2:</p> <p>Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Down</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= m, n &lt;= 100</code></li> </ul>"},{"location":"Advanced-4/#solution","title":"Solution","text":""},{"location":"Advanced-4/#question-understanding-","title":"Question Understanding-","text":"<p>Given are only two valid moves :</p> <ul> <li>Move right</li> <li>Move down     Hence, it is clear number of paths from cell (i,j) = sum of paths from cell( i+1,j) and cell(i,j+1)</li> </ul> <p>It becomes a DP problem. But implementing DP directly  will lead to TLE. So memoization is useful -&gt; Storing a result  so that we donot need to calculate it again.</p> <p>dp[i][j] = d[i+1][j] + dp[i][j+1]</p> <p>BASE CASES</p> <p>If we are in last row, i == m-1, we only have the choice to move RIGHT, Hence number of moves will be 1. If we are in last column, j == n-1, we only have the choice to move DOWN, Hence number of moves will be 1.</p>"},{"location":"Advanced-4/#top-down-dynamic-programming","title":"Top-Down Dynamic Programming:","text":"<p>Step 1: Initialize the Memoization Table</p> <ul> <li>Create a memoization table  (an auxiliary 2D array) of size m x n to store computed results. Initialize all entries to -1 to indicate that no results have been computed yet.</li> </ul> <p>Step 2: Recursive Function</p> <ul> <li>Implement a recursive function, say  uniquePathsRecursive(x, y, m, n, memo), which calculates the number of unique paths to reach cell (x, y) from the top-left corner.</li> <li> <p>In this function:</p> <ul> <li> <p>Check if (x, y) is the destination cell  (m - 1, n - 1). If yes, return 1 since there is one way to reach the destination.</p> </li> <li> <p>Check if the result for (x, y) is already computed  in the memoization table (memo[x][y] != -1).  If yes, return the stored result.</p> </li> <li> <p>Otherwise, calculate the number of unique paths  by recursively moving right and down (if valid) and adding the results.  Use the following logic:     \u27a1If (x, y) can move right  (i.e., x &lt; m - 1), calculate rightPaths = uniquePathsRecursive(x + 1, y, m, n, memo).     \u27a1  If (x, y) can move down  (i.e., y &lt; n - 1), calculate downPaths = uniquePathsRecursive(x, y + 1, m, n, memo).     \u27a1  The total unique paths to (x, y) are rightPaths + downPaths.     \u27a1 Store the result in the memoization table (memo[x][y]) and return it.</p> </li> </ul> </li> </ul>"},{"location":"Advanced-4/#code","title":"Code:","text":"<p><pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        # Create a memoization table to store computed results\n        memo = [[-1 for _ in range(n)] for _ in range(m)]\n\n        # Call the recursive function to compute unique paths\n        return self.uniquePathsRecursive(0, 0, m, n, memo)\n\n    def uniquePathsRecursive(self, x: int, y: int, m: int, n: int, memo: List[List[int]]) -&gt; int:\n        # If we reach the destination (bottom-right corner), return 1\n        if x == m - 1 and y == n - 1:\n            return 1\n\n        # If we have already computed the result for this cell, return it from the memo table\n        if memo[x][y] != -1:\n            return memo[x][y]\n\n        # Calculate the number of unique paths by moving right and down\n        rightPaths = 0\n        downPaths = 0\n\n        # Check if it's valid to move right\n        if x &lt; m - 1:\n            rightPaths = self.uniquePathsRecursive(x + 1, y, m, n, memo)\n\n        # Check if it's valid to move down\n        if y &lt; n - 1:\n            downPaths = self.uniquePathsRecursive(x, y + 1, m, n, memo)\n\n        # Store the result in the memo table and return it\n        memo[x][y] = rightPaths + downPaths\n        return memo[x][y]\n</code></pre> Step 3: Invoke the Recursive Function</p> <ul> <li>Call the recursive function with the initial arguments (0, 0, m, n, memo) to find the number of unique paths.</li> </ul> <p>Step 4: Return the Result</p> <ul> <li>The result obtained from the recursive function call represents the number of unique paths from the top-left corner to the bottom-right corner.</li> </ul>"},{"location":"Advanced-4/#bottom-up-dynamic-programming","title":"Bottom-Up Dynamic Programming:","text":"<p>Step 1: Initialize the DP Table</p> <ul> <li>Create a 2D DP (dynamic programming) table of  size m x n  to store the number of unique paths for each cell.</li> <li>Initialize the rightmost column and bottom row of the DP table to 1  because there's only one way to reach each cell in those rows/columns (by moving all the way right or all the way down).</li> </ul> <p>Step 2: Fill in the DP Table</p> <ul> <li>Start from the second-to-last  row and second-to-last column (i.e., i = m - 2 and j = n - 2).</li> <li>For each cell (i, j) in the grid:<ul> <li>Calculate the  number of unique paths to reach (i, j)  as the sum of the unique paths from the cell below (i+1, j) and  the cell to the right (i, j+1). Use this formula:  dp[i][j] = dp[i+1][j] + dp[i][j+1].</li> <li>Continue filling  in the DP table row by row and column by column until you reach the top-left corner (dp[0][0]).</li> </ul> </li> </ul> <p>Step 3: Return the Result</p> <ul> <li>Return the value stored in the top-left corner of the DP table (dp[0][0]), which represents the number of unique paths from the top-left corner to the bottom-right corner.</li> </ul>"},{"location":"Advanced-4/#code_1","title":"Code:","text":"<pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        # Create a 2D DP table filled with zeros\n        dp = [[0] * n for _ in range(m)]\n\n        # Initialize the rightmost column and bottom row to 1\n        for i in range(m):\n            dp[i][n-1] = 1\n        for j in range(n):\n            dp[m-1][j] = 1\n\n        # Fill in the DP table bottom-up\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\n\n        # Return the result stored in the top-left corner\n        return dp[0][0]\n</code></pre>"},{"location":"Advanced-4/#complexity","title":"Complexity","text":"<p>Bottom-Up Dynamic Programming: Time Complexity (TC):  The bottom-up approach fills in the DP table iteratively, visiting each cell once. There are m rows and n columns in the grid, so the TC is  O(m * n). Space Complexity (SC):  The space complexity is determined by the DP table, which is of size m x n. Therefore,  the SC is O(m * n)  to store the DP table.</p> <p>Top-Down Dynamic Programming (with Memoization): Time Complexity (TC):  O(m * n). Space Complexity (SC):  O(m + n).</p>"},{"location":"Advanced-4/#four-step-to-solution","title":"Four step to solution","text":""},{"location":"Advanced-4/#1-recursive-approach-top-to-down","title":"1. Recursive Approach--------&gt;Top to Down","text":"<pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        def solve(ind1,ind2):\n            if ind1==0 and ind2==0:\n                return 1\n            if ind1&lt;0  or ind2&lt;0:\n                return 0\n            return solve(ind1-1,ind2)+solve(ind1,ind2-1)\n        return solve(m-1,n-1)\n</code></pre>"},{"location":"Advanced-4/#2-memorization-approach","title":"2. Memorization Approach","text":"<pre><code>class Solution:\n   def uniquePaths(self, m: int, n: int) -&gt; int:\n       dp=[[-1]*(n+1) for i in range(m)]\n       def solve(ind1,ind2):\n           if ind1==0 and ind2==0:\n               return 1\n           if ind1&lt;0 or ind2&lt;0:\n               return 0\n           if dp[ind1][ind2]!=-1:\n               return dp[ind1][ind2]\n           left=solve(ind1,ind2-1)\n           up=solve(ind1-1,ind2)\n           dp[ind1][ind2]=up+left\n           return left+up\n       return solve(m-1,n-1)\n</code></pre>"},{"location":"Advanced-4/#3-tabulation-bottom-to-up-approach","title":"3. Tabulation------&gt;Bottom to Up Approach","text":"<pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        dp=[[0]*(n+1) for i in range(m+1)]\n        for ind1 in range(1,m+1):\n            for ind2 in range(1,n+1):\n                if ind1==ind2==1:\n                    dp[ind1][ind2]=1\n                else:\n                    left=up=0\n                    if ind2-1&gt;=0:\n                        left=dp[ind1][ind2-1]\n                    if ind1-1&gt;=0:\n                        up=dp[ind1-1][ind2]\n                    dp[ind1][ind2]=up+left\n        return dp[-1][-1]\n</code></pre>"},{"location":"Advanced-4/#4-space-optimization","title":"4. Space Optimization","text":"<pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        prev=[0]*(n+1)\n        for ind1 in range(1,m+1):\n            cur=[0]*(n+1)\n            for ind2 in range(1,n+1):\n                if ind1==ind2==1:\n                    cur[ind2]=1\n                else:\n                    left=up=0\n                    if ind2-1&gt;=0:\n                        left=cur[ind2-1]\n                    if ind1-1&gt;=0:\n                        up=prev[ind2]\n                    cur[ind2]=up+left\n            prev=cur\n        return cur[-1]\n</code></pre>"},{"location":"Beginner-1/","title":"C Programming Foundations","text":""},{"location":"Beginner-1/#introduction","title":"Introduction","text":"<p>Welcome to the world of C programming! In this guide, we'll cover essential concepts and problem-solving techniques that will set the foundation for your journey into the programming realm.</p>"},{"location":"Beginner-1/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Variables</li> <li>What are Variables?</li> <li>Problem: Calculate Rectangle Area</li> <li>Loops</li> <li>What are Loops?</li> <li>For Loop</li> <li>Problem: Factorial Calculation</li> <li>While Loop</li> <li>Problem: Print N numbers</li> <li>Do-While Loop</li> <li>Problem:  Add numbers entered by user</li> <li>Switch...Case</li> <li>Problem: Simple Calculator</li> <li>Conditional Statements</li> <li>What are Conditional Statements?</li> <li>if-else statement</li> <li>Problem: Leap Year Checker</li> <li>if-else ladder</li> <li>Nested if-else</li> <li>Arrays</li> <li>What are Arrays?</li> <li>Problem: Largest Element Finder</li> <li>Problem: Array Input/Output</li> <li>Problem: Calculate average</li> </ol>"},{"location":"Beginner-1/#variables-in-c","title":"Variables in C","text":""},{"location":"Beginner-1/#what-are-variables","title":"What are Variables?","text":"<p>In programming, variables are containers that store data. They have a type and a name.</p> <p><pre><code>int age;  // Declaration\nage = 21; // Assignment\n</code></pre> Note: The value of a variable can be changed, hence the name variable.</p> <pre><code>char ch = 'a';\nch = 'l';\n</code></pre> <p>C is a strongly typed language. This means that the variable type cannot be changed once it is declared. For example:</p> <pre><code>int number = 5;     // integer variable\nnumber = 5.5;       // error, can't assign float to int\ndouble number;      // error, can't redefine the data type \n</code></pre>"},{"location":"Beginner-1/#problem-calculate-rectangle-area","title":"Problem: Calculate Rectangle Area","text":"<p>Create a program that calculates the area of a rectangle given its length and width.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int length, width;\n    printf(\"Enter length: \");\n    scanf(\"%d\", &amp;length);\n    printf(\"Enter width: \");\n    scanf(\"%d\", &amp;width);\n\n    int area = length * width;\n    printf(\"Area: %d\\n\", area);\n}\n</code></pre>"},{"location":"Beginner-1/#loops-in-c","title":"Loops in C","text":""},{"location":"Beginner-1/#what-are-loops","title":"What are Loops?","text":"<p>In programming, a loop is used to repeat a block of code until the specified condition is met.</p>"},{"location":"Beginner-1/#for-loop","title":"For Loop","text":"<p><pre><code>for (int i = 0; i &lt; 5; i++) {\n    // Code inside the loop\n}\n</code></pre> Working of For Loop</p>"},{"location":"Beginner-1/#problem-factorial-calculation","title":"Problem: Factorial Calculation","text":"<p>Write a program to find the factorial of a number. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int number, factorial = 1;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &amp;number);\n\n    for (int i = 1; i &lt;= number; i++) {\n        factorial *= i;\n    }\n\n    printf(\"Factorial: %d\\n\", factorial);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"Beginner-1/#while-loop","title":"While loop","text":"<p>The syntax of the <code>while</code> loop is:</p> <p><pre><code>while (testExpression) {\n  // the body of the loop \n}\n</code></pre> Working of While Loop</p>"},{"location":"Beginner-1/#problem-print-n-numbers","title":"Problem: Print N numbers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int n, i;\n    // Input the value of n\n    printf(\"Enter the value of n: \");\n    scanf(\"%d\", &amp;n);\n    // Initialize a counter variable\n    i = 1;\n\n    // While loop to print the first n numbers\n    while (i &lt;= n) {\n        printf(\"%d \", i);\n        i++; // Increment the counter\n    }\n}\n</code></pre>"},{"location":"Beginner-1/#do-while-loop","title":"Do- While loop","text":"<p>The syntax of the <code>do-while</code> loop is:</p> <pre><code>do {\n  // the body of the loop\n}\nwhile (testExpression);\n</code></pre> <p> Working of do - while Loop</p>"},{"location":"Beginner-1/#problem-add-numbers-entered-by-user","title":"Problem: Add numbers entered by user","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\n  double number, sum = 0;\n\n  // the body of the loop is executed at least once\n  do {\n    printf(\"Enter a number: \");\n    scanf(\"%lf\", &amp;number);\n    sum += number;\n  }\n  while(number != 0.0);\n  printf(\"Sum = %.2lf\",sum);\n}\n</code></pre>"},{"location":"Beginner-1/#switchcase-loop","title":"Switch...case loop","text":"<p>The syntax of the <code>switch...case</code> loop is:</p> <pre><code>switch (expression)\n\u200b{\n    case constant1:\n      // statements\n      break;\n\n    case constant2:\n      // statements\n      break;\n    .\n    .\n    .\n    default:\n      // default statements\n}\n</code></pre> <p> Working of switch...case Loop</p>"},{"location":"Beginner-1/#problem-simple-calculator","title":"Problem: Simple Calculator","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char operation;\n    double n1, n2;\n\n    printf(\"Enter an operator (+, -, *, /): \");\n    scanf(\"%c\", &amp;operation);\n    printf(\"Enter two operands: \");\n    scanf(\"%lf %lf\",&amp;n1, &amp;n2);\n\n    switch(operation)\n    {\n        case '+':\n            printf(\"%.1lf + %.1lf = %.1lf\",n1, n2, n1+n2);\n            break;\n\n        case '-':\n            printf(\"%.1lf - %.1lf = %.1lf\",n1, n2, n1-n2);\n            break;\n\n        case '*':\n            printf(\"%.1lf * %.1lf = %.1lf\",n1, n2, n1*n2);\n            break;\n\n        case '/':\n            printf(\"%.1lf / %.1lf = %.1lf\",n1, n2, n1/n2);\n            break;\n\n        // operator doesn't match any case constant +, -, *, /\n        default:\n            printf(\"Error! operator is not correct\");\n    }\n}\n</code></pre>"},{"location":"Beginner-1/#conditional-statements-in-c","title":"Conditional Statements in C","text":""},{"location":"Beginner-1/#what-are-conditional-statements","title":"What are Conditional Statements?","text":"<p>Conditional statements help your program make decisions.</p>"},{"location":"Beginner-1/#if-else-statement","title":"if-else statement","text":"<p><pre><code>if (condition) {\n    // Code to execute if the condition is true\n} else {\n    // Code to execute if the condition is false\n}\n</code></pre> Working of if-else Loop</p>"},{"location":"Beginner-1/#problem-leap-year-checker","title":"Problem: Leap Year Checker","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int year;\n    printf(\"Enter a year: \");\n    scanf(\"%d\", &amp;year);\n\n    if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) {\n        printf(\"Leap year\\n\");\n    } else {\n        printf(\"Not a leap year\\n\");\n    }\n}\n</code></pre>"},{"location":"Beginner-1/#if-else-ladder","title":"if-else Ladder","text":"<p>Sometimes, a choice has to be made from more than 2 possibilities.</p> <p>The if...else ladder allows you to check between multiple test expressions and execute different statements. <pre><code>if (test expression1) {\n   // statement(s)\n}\nelse if(test expression2) {\n   // statement(s)\n}\nelse if (test expression3) {\n   // statement(s)\n}\n.\n.\nelse {\n   // statement(s)\n}\n</code></pre></p>"},{"location":"Beginner-1/#problem-if-else","title":"Problem: if- else","text":"<pre><code>// Program to relate two integers using =, &gt; or &lt; symbol\n\n#include &lt;stdio.h&gt;\nint main() {\n    int number1, number2;\n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &amp;number1, &amp;number2);\n\n    //checks if the two integers are equal.\n    if(number1 == number2) {\n        printf(\"Result: %d = %d\",number1,number2);\n    }\n\n    //checks if number1 is greater than number2.\n    else if (number1 &gt; number2) {\n        printf(\"Result: %d &gt; %d\", number1, number2);\n    }\n\n    //checks if both test expressions are false\n    else {\n        printf(\"Result: %d &lt; %d\",number1, number2);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Beginner-1/#nested-if-else","title":"Nested if-else","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    int number1, number2;\n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &amp;number1, &amp;number2);\n\n    if (number1 &gt;= number2) {\n      if (number1 == number2) {\n        printf(\"Result: %d = %d\",number1,number2);\n      }\n      else {\n        printf(\"Result: %d &gt; %d\", number1, number2);\n      }\n    }\n    else {\n        printf(\"Result: %d &lt; %d\",number1, number2);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Beginner-1/#arrays-in-c","title":"Arrays in C","text":""},{"location":"Beginner-1/#what-are-arrays","title":"What are Arrays?","text":"<p>Arrays allow you to store multiple values of the same type under one name.</p>"},{"location":"Beginner-1/#syntax","title":"Syntax","text":"<pre><code>dataType arrayName[arraySize];\n//example\nint numbers[5] = {1, 2, 3, 4, 5};` \n</code></pre>"},{"location":"Beginner-1/#access-array-elements","title":"Access Array Elements","text":"<p>You can access elements of an array by indices.</p> <p>Suppose you declared an array mark as above. The first element is mark[0], the second element is mark[1] and so on.</p> <p></p>"},{"location":"Beginner-1/#problem-largest-element-finder","title":"Problem: Largest Element Finder","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int numbers[] = {12, 45, 67, 23, 9};\n    int max = numbers[0];\n\n    for (int i = 1; i &lt; 5; i++) {\n        if (numbers[i] &gt; max) {\n            max = numbers[i];\n        }\n    }\n\n    printf(\"Largest element: %d\\n\", max);\n}\n</code></pre>"},{"location":"Beginner-1/#problem-array-inputoutput","title":"Problem: Array Input/Output","text":"<pre><code>// Program to take 5 values from the user and store them in an array\n// Print the elements stored in the array\n\n#include &lt;stdio.h&gt;\n\nint main() {\n\n  int values[5];\n\n  printf(\"Enter 5 integers: \");\n\n  // taking input and storing it in an array\n  for(int i = 0; i &lt; 5; ++i) {\n     scanf(\"%d\", &amp;values[i]);\n  }\n\n  printf(\"Displaying integers: \");\n\n  // printing elements of an array\n  for(int i = 0; i &lt; 5; ++i) {\n     printf(\"%d\\n\", values[i]);\n  }\n  return 0;\n}\n</code></pre>"},{"location":"Beginner-1/#problem-calculate-average","title":"Problem: Calculate average","text":""},{"location":"Beginner-1/#include-stdioh-int-main-int-marks10-i-n-sum-0-double-average-printfenter-number-of-elements-scanfd-n-fori0-i-n-i-printfenter-numberd-i1-scanfd-marksi-adding-integers-entered-by-the-user-to-the-sum-variable-sum-marksi-explicitly-convert-sum-to-double-then-calculate-average-average-double-sum-n-printfaverage-2lf-average-return-0","title":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n  int marks[10], i, n, sum = 0;\n  double average;\n\n  printf(\"Enter number of elements: \");\n  scanf(\"%d\", &amp;n);\n\n  for(i=0; i &lt; n; ++i) {\n    printf(\"Enter number%d: \",i+1);\n    scanf(\"%d\", &amp;marks[i]);\n\n    // adding integers entered by the user to the sum variable\n    sum += marks[i];\n  }\n\n  // explicitly convert sum to double\n  // then calculate average\n  average = (double) sum / n;\n\n  printf(\"Average = %.2lf\", average);\n\n  return 0;\n}\n</code></pre>","text":"<p>Congratulations on completing this C programming foundations! Remember, practice is key to mastering programming. Explore more, solve problems, and enjoy the journey of coding! Happy coding! \ud83d\ude04 </p> <p></p>"},{"location":"Beginner-2/","title":"C Programming Foundations","text":""},{"location":"Beginner-2/#introduction","title":"Introduction","text":"<p>Welcome to the world of C programming! In this guide, we'll cover essential concepts and problem-solving techniques that will set the foundation for your journey into the programming realm.</p>"},{"location":"Beginner-2/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Variables</li> <li>What are Variables?</li> <li>Using Variables</li> <li>Loops</li> <li>What are Loops?</li> <li>For Loop</li> <li>Problem: Factorial Calculation</li> <li>While Loop</li> <li>Problem: Print N numbers</li> <li>Do-While Loop</li> <li>Problem:  Add numbers entered by user</li> <li>Switch...Case</li> <li>Problem: Simple Calculator</li> <li>Conditional Statements</li> <li>What are Conditional Statements?</li> <li>if-else statement</li> <li>Problem: Leap Year Checker</li> <li>if-else ladder</li> <li>Nested if-else</li> <li>Arrays</li> <li>What are Arrays?</li> <li>Past Year Questions</li> </ol>"},{"location":"Beginner-2/#variables-in-c","title":"Variables in C","text":""},{"location":"Beginner-2/#what-are-variables","title":"What are Variables?","text":"<p>In programming, variables are containers that store data. They have a type and a name.</p> <p><pre><code>int age;  // Declaration\nage = 21; // Assignment\n</code></pre> Note: The value of a variable can be changed, hence the name variable.</p> <pre><code>char ch = 'a';\nch = 'l';\n</code></pre> <p>C is a strongly typed language. This means that the variable type cannot be changed once it is declared. For example:</p> <pre><code>int number = 5;     // integer variable\nnumber = 5.5;       // error, can't assign float to int\ndouble number;      // error, can't redefine the data type \n</code></pre>"},{"location":"Beginner-2/#using-variables","title":"Using variables","text":"<p>Once a variable has been declared and initialized, you can use it in your program to store and retrieve data. For example, the following code prints the value of the variable <code>age</code> to the console:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  int age = 25;\n\n  printf(\"My age is %d\\n\", age);\n\n  return 0;\n}\n</code></pre>"},{"location":"Beginner-2/#loops-in-c","title":"Loops in C","text":""},{"location":"Beginner-2/#what-are-loops","title":"What are Loops?","text":"<p>In programming, a loop is used to repeat a block of code until the specified condition is met.</p>"},{"location":"Beginner-2/#for-loop","title":"For Loop","text":"<p><pre><code>for (int i = 0; i &lt; 5; i++) {\n    // Code inside the loop\n}\n</code></pre> Working of For Loop</p>"},{"location":"Beginner-2/#problem-factorial-calculation","title":"Problem: Factorial Calculation","text":"<p>Write a program to find the factorial of a number. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {                        // return type int\n    int number, factorial = 1;\n\n    printf(\"Enter a number: \");   //Prints text to console\n    scanf(\"%d\", &amp;number);         //Reads input from console\n\n    for (int i = 1; i &lt;= number; i++) {\n        factorial *= i;\n    }\n\n    printf(\"Factorial: %d\\n\", factorial);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"Beginner-2/#while-loop","title":"While loop","text":"<p>The syntax of the <code>while</code> loop is:</p> <p><pre><code>while (testExpression) {\n  // the body of the loop \n}\n</code></pre> Working of While Loop</p>"},{"location":"Beginner-2/#problem-print-n-numbers","title":"Problem: Print N numbers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid main() {                             //return type void\n    int n, i;\n    // Input the value of n\n    printf(\"Enter the value of n: \");\n    scanf(\"%d\", &amp;n);\n    // Initialize a counter variable\n    i = 1;\n\n    // While loop to print the first n numbers\n    while (i &lt;= n) {\n        printf(\"%d \", i);\n        i++; // Increment the counter\n    }\n}\n</code></pre>"},{"location":"Beginner-2/#do-while-loop","title":"Do- While loop","text":"<p>The syntax of the <code>do-while</code> loop is:</p> <pre><code>do {\n  // the body of the loop\n}\nwhile (testExpression);\n</code></pre> <p> Working of do - while Loop</p>"},{"location":"Beginner-2/#problem-add-numbers-entered-by-user","title":"Problem: Add numbers entered by user","text":"<pre><code>#include &lt;stdio.h&gt;\nvoid main() {\n  double number, sum = 0;\n\n  // the body of the loop is executed at least once\n  do {\n    printf(\"Enter a number: \");\n    scanf(\"%lf\", &amp;number);\n    sum += number;\n  }\n  while(number != 0.0);\n  printf(\"Sum = %.2lf\",sum);\n}\n</code></pre>"},{"location":"Beginner-2/#switchcase-loop","title":"Switch...case loop","text":"<p>The syntax of the <code>switch...case</code> loop is:</p> <pre><code>switch (expression)\n\u200b{\n    case constant1:\n      // statements\n      break;\n\n    case constant2:\n      // statements\n      break;\n    .\n    .\n    .\n    default:\n      // default statements\n}\n</code></pre> <p> Working of switch...case Loop</p>"},{"location":"Beginner-2/#problem-simple-calculator","title":"Problem: Simple Calculator","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char operation;\n    double n1, n2;\n\n    printf(\"Enter an operator (+, -, *, /): \");\n    scanf(\"%c\", &amp;operation);\n    printf(\"Enter two operands: \");\n    scanf(\"%lf %lf\",&amp;n1, &amp;n2);    //lf reads type \"double\"\n\n    switch(operation)\n    {\n        case '+':\n            printf(\"%.1lf + %.1lf = %.1lf\",n1, n2, n1+n2);\n            break;\n\n        case '-':\n            printf(\"%.1lf - %.1lf = %.1lf\",n1, n2, n1-n2);\n            break;\n\n        case '*':\n            printf(\"%.1lf * %.1lf = %.1lf\",n1, n2, n1*n2);\n            break;\n\n        case '/':\n            printf(\"%.1lf / %.1lf = %.1lf\",n1, n2, n1/n2);\n            break;\n\n        // operator doesn't match any case constant +, -, *, /\n        default:\n            printf(\"Error! operator is not correct\");\n    }\n}\n</code></pre>"},{"location":"Beginner-2/#conditional-statements-in-c","title":"Conditional Statements in C","text":""},{"location":"Beginner-2/#what-are-conditional-statements","title":"What are Conditional Statements?","text":"<p>Conditional statements help your program make decisions.</p>"},{"location":"Beginner-2/#if-else-statement","title":"if-else statement","text":"<p><pre><code>if (condition) {\n    // Code to execute if the condition is true\n} else {\n    // Code to execute if the condition is false\n}\n</code></pre> Working of if-else Loop</p>"},{"location":"Beginner-2/#problem-leap-year-checker","title":"Problem: Leap Year Checker","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid main() {\n    int year;\n    printf(\"Enter a year: \");\n    scanf(\"%d\", &amp;year);\n\n    if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) {\n        printf(\"Leap year\\n\");\n    } else {\n        printf(\"Not a leap year\\n\");\n    }\n}\n</code></pre>"},{"location":"Beginner-2/#if-else-ladder","title":"if-else Ladder","text":"<p>Sometimes, a choice has to be made from more than 2 possibilities.</p> <p>The if...else ladder allows you to check between multiple test expressions and execute different statements. <pre><code>if (test expression1) {\n   // statement(s)\n}\nelse if(test expression2) {\n   // statement(s)\n}\nelse if (test expression3) {\n   // statement(s)\n}\n.\n.\nelse {\n   // statement(s)\n}\n</code></pre></p>"},{"location":"Beginner-2/#problem-if-else","title":"Problem: if- else","text":"<pre><code>// Program to relate two integers using =, &gt; or &lt; symbol\n\n#include &lt;stdio.h&gt;\nint main() {\n    int number1, number2;\n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &amp;number1, &amp;number2);\n\n    //checks if the two integers are equal.\n    if(number1 == number2) {\n        printf(\"Result: %d = %d\",number1,number2);\n    }\n\n    //checks if number1 is greater than number2.\n    else if (number1 &gt; number2) {\n        printf(\"Result: %d &gt; %d\", number1, number2);\n    }\n\n    //checks if both test expressions are false\n    else {\n        printf(\"Result: %d &lt; %d\",number1, number2);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Beginner-2/#nested-if-else","title":"Nested if-else","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    int number1, number2;\n    printf(\"Enter two integers: \");\n    scanf(\"%d %d\", &amp;number1, &amp;number2);\n\n    if (number1 &gt;= number2) {\n      if (number1 == number2) {\n        printf(\"Result: %d = %d\",number1,number2);\n      }\n      else {\n        printf(\"Result: %d &gt; %d\", number1, number2);\n      }\n    }\n    else {\n        printf(\"Result: %d &lt; %d\",number1, number2);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Beginner-2/#arrays-in-c","title":"Arrays in C","text":""},{"location":"Beginner-2/#what-are-arrays","title":"What are Arrays?","text":"<p>Arrays allow you to store multiple values of the same type under one name.</p>"},{"location":"Beginner-2/#syntax","title":"Syntax","text":"<p><pre><code>dataType arrayName[arraySize];\n//example\nint numbers[5] = {1, 2, 3, 4, 5};` \n</code></pre> </p>"},{"location":"Beginner-2/#access-array-elements","title":"Access Array Elements","text":"<p>You can access elements of an array by indices.</p> <p>Suppose you declared an array mark as above. The first element is mark[0], the second element is mark[1] and so on.</p> <p></p>"},{"location":"Beginner-2/#past-year-questions","title":"Past Year Questions \ud83e\udd29\ud83e\udd29\ud83e\udd29","text":"<p>1) Write a C Program to input size of the array, and then replace each element of the user input array with its reverse. Print the array.</p> <pre><code>//Solution\n#include &lt;stdio.h&gt;\n\nvoid main() {\n    int size;\n\n    // Input the size of the array\n    printf(\"Enter the size of the array: \");\n    scanf(\"%d\", &amp;size);\n\n    int arr[size];\n\n    // Input array elements\n    printf(\"Enter %d elements:\\n\", size);\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"Enter element %d :\",i+1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    // Print the original array\n    printf(\"Original Array: \");\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    // Reverse the array in-place\n    int start = 0;\n    int end = size - 1;\n    while (start &lt; end) {\n        // Swap elements at start and end\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n\n        // Move the start and end pointers\n        start++;\n        end--;\n    }\n\n    // Print the array after the reversal\n    printf(\"Array After Reversal: \");\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>2) WAP to sort an array A[] consisting of only 1s, 2s, and 3s. the following task needs to be done</p> <ul> <li>The program should sort the given array and put all 1s first, then all 2s and all 3s in last.</li> <li>Print the array elements after sorting.</li> </ul> <p></p> <p>Test case 1:</p> <p>Input: {1, 2, 3, 1, 2, 3}</p> <p>Output: {1, 1, 2, 2, 3, 3}</p> <p></p> <p>Test case 2:</p> <p>Input: {1, 2, 2, 1, 2, 3, 2, 3, 1, 1, 1, 2}</p> <p>Output: {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3}</p> <pre><code>//Solution\n#include &lt;stdio.h&gt;\n\nint main() {\n    int size;\n\n    // Input the size of the array\n    printf(\"Enter the size of the array: \");\n    scanf(\"%d\", &amp;size);\n\n    int arr[size];\n\n    // Input array elements\n    printf(\"Enter %d elements (1, 2, or 3):\\n\", size);\n    for (int i = 0; i &lt; size; i++) {\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    int count1 = 0, count2 = 0, count3 = 0;\n\n    // Count the occurrences of 1, 2, and 3 in the array\n    for (int i = 0; i &lt; size; i++) {\n        if (arr[i] == 1) {\n            count1++;\n        } else if (arr[i] == 2) {\n            count2++;\n        } else if (arr[i] == 3) {\n            count3++;\n        }\n    }\n\n    // Overwrite the array with the sorted elements\n    for (int i = 0; i &lt; count1; i++) {\n        arr[i] = 1;\n    }\n\n    for (int i = count1; i &lt; count1 + count2; i++) {\n        arr[i] = 2;\n    }\n\n    for (int i = count1 + count2; i &lt; size; i++) {\n        arr[i] = 3;\n    }\n\n    // Print the sorted array\n    printf(\"Array After Sorting: \");\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre> <p>Congratulations on completing this C programming foundations! Remember, practice is key to mastering programming. Explore more, solve problems, and enjoy the journey of coding! Happy coding! \ud83d\ude04 </p> <p></p>"},{"location":"Beginner-3/","title":"C Programming Foundations","text":""},{"location":"Beginner-3/#introduction","title":"Introduction","text":"<p>Welcome to the world of C programming! In this guide, we'll cover functions and logical thinking techniques that will set the foundation for your journey into the programming realm.</p>"},{"location":"Beginner-3/#functions-the-building-blocks-of-c-programming","title":"Functions: The Building Blocks of C Programming","text":"<p>Imagine you're a chef preparing a scrumptious dish. You wouldn't just toss all the ingredients into a pot and hope for the best. Instead, you'd carefully follow a recipe, breaking down the cooking process into manageable steps. Similarly, C programming utilizes functions to break down complex tasks into reusable and organized units. Think of it as building up a burger, you make each part separately and then combine all of them at the end.</p>"},{"location":"Beginner-3/#whats-a-function","title":"What's a Function?","text":"<p>A function is a block of code designed to perform a specific task. It's like a mini-program within your main program, allowing you to organize your code and make it easier to manage. It is your sous chef, assisting you in preparing various components of the dish, to make the perfect \"Better-than-Gordon-Ramsay \ud83d\ude0e\" dish.</p>"},{"location":"Beginner-3/#function-structure","title":"Function Structure","text":"<p>Every function has a well-defined structure, much like a well-structured recipe. Let's dissect the anatomy of a function:</p> <ol> <li>Function Declaration: This is the function's name tag, introducing it to the program. It tells the program what the function is called and what it does. Just like everybody else you know, functions also identify by these \"proper nouns\".</li> </ol> <pre><code>void greet(char name[]) {\n  //Name of function \u21d2 greet\n  printf(\"Good Morning Legend\\n\");\n  // Function's remaining body\n}\n</code></pre> <ol> <li>Return Type: This indicates the type of data the function produces, like the dessert you're serving after the main course. Return types can be of various datatypes: int, float, double, string or even an entire array or structure!! An example with int is as follows</li> </ol> <pre><code>int addNumbers(int num1, int num2) {\n  int sum = num1 + num2; // Value to return must be of the same type\n  return sum // Do not forget this very important line!!\n}\n</code></pre> <ol> <li>Parameter List: This is the list of ingredients your function needs to do its job, like the spices you add to enhance the flavor. For calculating average, we need to take an array of numbers and the number of students </li> </ol> <pre><code>float calculateAverage(int marks[], int numStudents) {\n  float sum = 0.0; //FoodForThought ==&gt; Why sum float not int?\n\n  for (int i = 0; i &lt; numStudents; i++) { \n      sum += marks[i]; \n  } \n\n  float average = sum / numStudents; \n  return average; \n}\n</code></pre> <ol> <li>Function Body: This is where the action happens, like the cooking instructions that transform raw ingredients into a culinary masterpiece.</li> </ol> <pre><code>void swapValues(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}\n</code></pre>"},{"location":"Beginner-3/#function-calling-putting-the-sous-chef-to-work","title":"Function Calling: Putting the Sous Chef to Work","text":"<p>To put your function to work, you need to call it, just like you'd call your sous chef to assist with your Mastershef Dish</p> <pre><code>int num1 = 10, num2 = 20;\nint sum = addNumbers(num1, num2);\nprintf(\"The sum of %d and %d is %d\\n\", num1, num2, sum);\n</code></pre>"},{"location":"Beginner-3/#expanding-your-culinary-skills","title":"Expanding Your Culinary Skills","text":"<ol> <li>Reversing a String: Write a function that takes a string as input and returns the reversed string.</li> </ol> <pre><code>char *reverseString(char str[]) {\n  int len = strlen(str);\n  char revStr[len + 1];\n\n  for (int i = 0; i &lt; len; i++) {\n    revStr[i] = str[len - 1 - i];\n  }\n\n  revStr[len] = '\\0';\n  return revStr;\n}\n</code></pre> <ol> <li>Finding the Largest Element in an Array: Write a function that takes an integer array and its size as input and returns the index of the largest element.</li> </ol> <pre><code>int findLargest(int arr[], int size) {\n  int largestIndex = 0;\n  int max = arr[0];\n\n  for (int i = 1; i &lt; size; i++) {\n    if (arr[i] &gt; max) {\n      max = arr[i];\n      largestIndex = i;\n    }\n  }\n\n  return largestIndex;\n}\n</code></pre>"},{"location":"Beginner-3/#logical-thinking-in-c","title":"Logical Thinking in C","text":""},{"location":"Beginner-3/#what-is-logical-thinking","title":"What is logical thinking?","text":"<p>Logical thinking is essential for writing good C code. You need to be able to think about how your code will be executed and how the different parts of your code will interact with each other.</p>"},{"location":"Beginner-3/#how-to-think-logically-in-c","title":"How to think logically in C","text":"<p>To use logical thinking in C programming, you need to be able to think about the steps involved in solving a problem and express those steps in C code. By using this 5 step approach you will not only develop the ability to independently write and edit code, but will also become logical thinkers.</p> <p>1.  Analyze the Problem 2.  Formulate a Plan 3.  Develop Code to Solve the Problem 4.  Evaluate the Solution and Revise the Code 5.  Justify Decisions</p> <p>Here are some tips for logical thinking in C:</p> <ul> <li>Use functions to organize your code. This will make your code more readable and easier to maintain.</li> <li>Use comments to explain what your code is doing. This will help you and other people understand your code.</li> <li>Use variables to store data. This will make your code more efficient and reusable.</li> <li>Use conditional statements to control the flow of your code. This will allow you to execute different parts of your code depending on different conditions.</li> <li>Use loops to repeat blocks of code. This will save you from having to write the same code multiple times.</li> </ul>"},{"location":"Beginner-3/#questions","title":"Questions","text":""},{"location":"Beginner-3/#fibonacci-series-in-c","title":"Fibonacci Series in C","text":"<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\n\nint number_of_terms, iteration;\nint term1 = 0, term2 = 1, next_term;\n\nprintf(\"Enter the number of terms till you want to display the numbers in the Fibonacci series: \");\nscanf(\"%d\", &amp;number_of_terms);\n\nprintf(\"The Fibonacci series up till %d terms is: \",number_of_terms);\n\nfor (iteration = 1; iteration &lt;= number_of_terms; iteration++)\n{\nprintf(\"%d \", term1);\nnext_term = term1 + term2; // Next term is the sum of previous terms\nterm1 = term2;\nterm2 = next_term;\n}\nreturn 0;\n}\n</code></pre>"},{"location":"Beginner-3/#elucidation","title":"Elucidation","text":"<p>Declaration: We declare the variable \u2018number_of_terms\u2019 to find the terms till which the series is to be displayed, the variable \u2018iteration\u2019 to traverse the for loop. Then, we initialize the first and second term as 0 and 1 respectively are their values are fixed.</p> <p>Input: We take the input of the number of terms to be entered by the user till which he wishes to display the Fibonacci series.</p> <p>Logic: We initialize the variable \u2018iteration\u2019 to 1. We make the loop run till the number of terms in the series and print the first term and second term.</p> <ul> <li>Now, our task is to find the sum of both the terms, that is, 0 and 1 to obtain the next term.</li> <li>When the loop runs for the second time, we store the result obtained, that is, 2, to the second term and the original second term to the original first term.</li> <li>The same process is repeated until the variable \u2018iteration\u2019 becomes equal to the number of terms.</li> </ul>"},{"location":"Beginner-3/#palindrome-series-in-c","title":"Palindrome Series in C","text":"<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n\nint number, number_reverse = 0, remainder, original_number;\n\nprintf(\"Enter an integer: \");\nscanf(\"%d\", &amp;number);\n\noriginal_number = number; // Storing the value of the number into a variable original_number\n\n/* Reversing the number */\nwhile( number!=0 )\n{\nremainder = number % 10;\nnumber_reverse = number_reverse * 10 + remainder;\nnumber /= 10;\n}\n// To check if the original number and the reversed number are equal or not\nif (original_number == number_reverse)\nprintf(\"%d is a palindrome.\\n\", original_number);\nelse\nprintf(\"%d is not a palindrome.\\n\", original_number);\nreturn 0;\n}\n</code></pre>"},{"location":"Beginner-3/#elucidation_1","title":"Elucidation","text":"<p>Declaration: We declare the variable \u2018number\u2019 to store the value entered by the user to check if it is a palindrome or not, the variable \u2018remainder\u2019 to find the remainder when the integral division of that number is performed with 10, and the variable \u2018original_number\u2019 to store the value of the number entered by the user temporarily. We initialize the variable \u2018number_reverse to 0 for loop traversal.</p> <p>Input: We take the input of the number to check if it is a palindrome or not from the user in the variable \u2018number\u2019.</p> <p>Logic: The while loop runs till the number entered by the user becomes 0</p> <ul> <li>A set of conditions is given to extract the reversed number from the number entered by the user.</li> <li>If the value of the variable \u2018number_reverse\u2019 matches to that of the original number, then the given number enter by the user is a palindrome.</li> </ul>"},{"location":"Beginner-3/#explanation-through-dry-run","title":"Explanation through Dry Run:","text":"<p>Consider the value of the number = 181</p> <p>The while loop will run for 3 times, given as:</p> <p>1. First iteration, number = 181 <pre><code>remainder = 181 % 10 = 1  \nnumber_reverse = ( 0 * 10 ) + 1 = 1  \nnumber = 181 / 10 = 18\n</code></pre> 2. Second iteration, number = 18 <pre><code>remainder = 18 % 10 = 8  \nnumber_reverse = ( 1 * 10 ) + 8 = 18  \nnumber = 18 / 10 = 1\n</code></pre> 3. Third iteration, number = 1 <pre><code>remainder = 1 % 10 = 1  \nnumber_reverse = ( 18 * 10 ) + 1 = 181  \nnumber = 1 / 10 = 0\n</code></pre> The loop will no longer run as the base condition no longer continues to be satisfied as the number reached its minimum value = 0.</p> <p>Congratulations on completing this C programming foundations! Remember, practice is key to mastering programming. Explore more, solve problems, and enjoy the journey of coding! Happy coding! \ud83d\ude04 </p> <p></p>"},{"location":"Beginner-4/","title":"Pointers in C: A Guide to Mastering the Art","text":""},{"location":"Beginner-4/#introduction","title":"Introduction","text":"<p>Welcome to the fascinating world of pointers in C, where memory addresses become your dance partners and dereferencing becomes your second language. Pointers are like powerful tools that can unlock the secrets of memory management and dynamic data structures, but they can also be a source of confusion and frustration if not handled with care.</p> <p>In this session, we'll embark on a debugging adventure. We'll explore the concepts of memory addresses, dereferencing, pointer arithmetic &amp; functions, and debugging, all while injecting a dose of humor to keep things engaging.</p>"},{"location":"Beginner-4/#table-of-contents","title":"Table of Contents","text":"<ol> <li>What on Earth is a Pointer?</li> <li>Declaring and Initializing Pointers</li> <li>Dereferencing Pointers</li> <li>Pointer Arithmetic</li> <li>Arrays and Pointers</li> <li>Pointers and Functions</li> <li>Common Pitfalls and Challenges</li> <li>Question</li> <li>Deadly Debugging</li> <li>Conclusion</li> </ol>"},{"location":"Beginner-4/#what-on-earth-is-a-pointer","title":"What on Earth is a Pointer?","text":"<p>A pointer is a variable that stores the memory address of another variable. A pointer variable allows your code to find the location of another variable in memory.</p> <p>In C, a pointer is like a GPS for your program, allowing you to navigate through the vast landscape of memory.</p> <p>Syntax to declare a pointer:</p> <pre><code>dataType *pointerName; \n</code></pre>"},{"location":"Beginner-4/#declaring-and-initializing-pointers","title":"Declaring and Initializing Pointers","text":"<p>Declaring a pointer is as simple as putting an asterisk (*) before the variable name. </p> <p>Declaring a pointer is like reserving a space for an address label.</p> <p>Initializing it involves assigning the memory address of another variable.</p> <p>Example: <pre><code>int num = 42;\nint *pNum;       // Declaration\npNum = &amp;num;     // Initialization (pNum now points to the memory address of num)\n</code></pre></p> <p>Question 1: What happens if you try to initialize a pointer without declaring it first?</p> <p>Hint: The compiler might not appreciate surprises!</p> <p>Question 2: What's wrong with this pointer code? </p> <pre><code>int *p;\n*p = 10; \n</code></pre> Answer  <p>  p is uninitialized and points to a random memory location. Dereferencing p can crash the program.  </p>"},{"location":"Beginner-4/#dereferencing-pointers","title":"Dereferencing Pointers","text":"<p>To access the actual value stored in the memory location being pointed to, you need to dereference the pointer using the <code>*</code> operator. </p> <p>It's like following a treasure map to find the hidden treasure!</p> <p>Example: <pre><code>int value = *pNum; // value now holds the content of the memory location pointed by pNum\nprintf(\"num is: %d\\n\", num); // prints 42\nprintf(\"*pNUm is: %d\", value); // prints 42\n</code></pre></p> <p>Question 3: What would happen if you dereference a pointer that hasn't been initialized?</p> <p>Hint: The treasure map is blank!</p>"},{"location":"Beginner-4/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<p>Pointers can be used to access elements of an array. This is done by adding an integer to the pointer, which moves the pointer forward by the size of the data type.</p> <p>Pointer arithmetic is like navigating through a maze of memory addresses.</p> <p>Example: <pre><code>int arr[5] = {1, 2, 3, 4, 5};\nint *pArr = arr;\n\n// Accessing elements using pointer arithmetic\nint thirdElement = *(pArr + 2); // This gets the third element (index 2) of the array\n</code></pre></p> <p>Question 4: Explain the difference between <code>*(pArr + 2)</code> and <code>pArr[2]</code>.</p> <p>Hint: It's like choosing between a labyrinth and a shortcut!</p> <p>Question 5: What is output of this program?</p> <pre><code>int x = 5;\nint *p = &amp;x; \n\n(*p)++;\n\nprintf(\"%d %d\", x, *p);\n</code></pre> <ul> <li>6 6  </li> <li>5 5</li> <li>6 5</li> <li>5 6</li> </ul> Answer <p>   The output is 6 6.   * `p` points to x  * `(*p)++` dereferences p and increments x to 6 * So x is now 6, and *p is 6 as well since p points to x  </p>"},{"location":"Beginner-4/#arrays-and-pointers","title":"Arrays and Pointers","text":"<p>In C, arrays and pointers share a mysterious connection. An array name is essentially a pointer to its first element.</p> <p>Example: <pre><code>int numbers[3] = {10, 20, 30};\nint *pNumbers = numbers;\n\n// Both expressions are equivalent\nint firstElement = numbers[0];\nint alsoFirstElement = *pNumbers;\n</code></pre></p> <p>Question 6: Can you explain why <code>sizeof(numbers)</code> is different from <code>sizeof(pNumbers)</code>?</p> <p>Hint: It's a matter of perspective!</p>"},{"location":"Beginner-4/#pointers-and-functions","title":"Pointers and Functions","text":"<p>Pointers can be passed to functions, allowing them to modify values outside their scope. This is efficient compared to copying large amounts of data.</p> <p>It's like sending a scout to explore unknown territories.</p> <p>Example: <pre><code>void doubleValue(int *x) {\n    *x = *x * 2;\n}\n\nint main() {\n    int num = 5;\n    doubleValue(&amp;num); // num is now 10\n    return 0;\n}\n</code></pre></p>"},{"location":"Beginner-4/#common-pitfalls-and-challenges","title":"Common Pitfalls and Challenges","text":"<ol> <li> <p>Dangling Pointers: Be cautious not to keep a pointer pointing to a memory location that has been deallocated.</p> </li> <li> <p>Memory Leaks: Always free the memory you allocate dynamically. Zombies belong in movies, not in your code!</p> </li> <li> <p>Wild Pointers: Initialize your pointers before using them; otherwise, you might be pointing to who-knows-where.</p> </li> <li> <p>Array Boundaries: Be mindful of going beyond the boundaries of arrays. Memory is a delicate ecosystem!</p> </li> <li> <p>Pointer Arithmetic: Be careful when using pointer arithmetic. It's easy to get lost in the maze of memory addresses.</p> </li> </ol>"},{"location":"Beginner-4/#question","title":"Question","text":"<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n   int* pc, c;\n\n   c = 22;\n   printf(\"Address of c: %p\\n\", &amp;c);\n   printf(\"Value of c: %d\\n\\n\", c);  // 22\n\n   pc = &amp;c;\n   printf(\"Address of pointer pc: %p\\n\", pc);\n   printf(\"Content of pointer pc: %d\\n\\n\", *pc); // 22\n\n   c = 11;\n   printf(\"Address of pointer pc: %p\\n\", pc);\n   printf(\"Content of pointer pc: %d\\n\\n\", *pc); // 11\n\n   *pc = 2;\n   printf(\"Address of c: %p\\n\", &amp;c);\n   printf(\"Value of c: %d\\n\\n\", c); // 2\n   return 0;\n}\n</code></pre> <p>Output</p> <pre><code>Address of c: 2686784\nValue of c: 22\n\nAddress of pointer pc: 2686784\nContent of pointer pc: 22\n\nAddress of pointer pc: 2686784\nContent of pointer pc: 11\n\nAddress of c: 2686784\nValue of c: 2\n</code></pre>"},{"location":"Beginner-4/#deadly-debugging","title":"Deadly Debugging","text":"<p>Debugging, the art of hunting down and eliminating bugs in your code, is an essential skill for any programmer. It's like being a detective, meticulously examining the clues left behind by your code to uncover the culprit behind its misbehavior. In the world of C programming, debugging can be a daunting task, but with the right approach, it can be a rewarding experience.</p> <p>Your primary weapon in this debugging crusade is your compiler. The compiler scrutinizes your code, flagging any syntactical errors or inconsistencies that might be causing problems (Just like your mom over your shoulder in 2nd grade :) )</p> <p>As you delve into the debugging process, there are a few key strategies to keep in mind:</p> <ol> <li> <p>Reproduce the Bug: Before you can fix it, you need to be able to consistently reproduce the bug. This might involve running your program multiple times with different inputs or setting up specific conditions to trigger the error. This can help you find out if there is a particular test case showing the error or all of them not working at all :(.</p> </li> <li> <p>Identify Symptoms: Carefully observe the symptoms of the bug. Is your program crashing unexpectedly? Is it producing incorrect output? Analyzing the symptoms can provide valuable clues about the underlying cause.</p> </li> <li> <p>Simplify the Problem: Break down the problem into smaller, more manageable pieces. This can involve isolating specific sections of code, removing extraneous elements, or temporarily disabling certain features to pinpoint the source of the bug.</p> </li> <li> <p>Use Debugging Tools: Employ your compiler and debugger to their fullest potential. Set breakpoints, print statements, inspect variables, and step through your code to identify where the program's behavior deviates from expectations.</p> </li> <li> <p>Seek Help: Don't hesitate to seek help from fellow programmers, online forums, or documentation. A fresh perspective can often lead to the breakthrough you need. (Sleeping and praying to god helps too (Tried and Tested, trust us :) ) ).</p> </li> </ol> <p>Here is an example of a simple C program with a bug and a step-by-step process of debugging it:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int sum = 0;\n    for (int i = 0; i &lt;= 10; i++) {\n        sum *= i;\n    }\n\n    printf(\"The sum is: %d\\n\", sum);\n\n    return 0;\n}\n</code></pre> <p>This program is supposed to calculate the sum of the numbers from 0 to 10. However, there is a bug in the program that is causing it to print an incorrect value.</p> <p>Step 1: Compile the program</p> <p>The first step is to compile and run the program to view the output. In an average programmer's life, logical errors are their worst enemy. These errors disguise themselves within the program because they don't throw up a syntax error.</p> <p>The above print the following output:</p> <pre><code>The sum is: 0\n</code></pre> <p>The program is clearly not printing the correct sum, which should be 55.</p> <p>Step 3: Use a print statements</p> <p>Print statements are underestimated friends of ours. Carefully placing a print statement can show us the flow of the program and help us understand where we are going wrong</p> <p>The program becomes something as follows</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int sum = 0;\n    for (int i = 0; i &lt;= 10; i++) {\n    printf(\"The running sum is: %d\\n\", sum);\n        sum *= i;\n    }\n\n    printf(\"The sum is: %d\\n\", sum);\n\n    return 0;\n}\n</code></pre> <p>You will find that, the value of the <code>sum</code> variable is 0 at all points in the program.</p> <p>Step 8: Find the bug</p> <p>By stepping through the program, you will eventually find the bug. In this case, the bug is that the condition of the the sum increment is incorrect. The condition should be <code>sum+=i</code>, not <code>sum*=i</code>.</p> <p>Step 9: Fix the bug</p> <p>Edit the program to fix the bug. Save the changes and then recompile the program.</p> <p>Step 10: Run the program again</p> <p>Run the program again to make sure that the bug has been fixed. The program should now print the correct sum, which is 55.</p> <p>This is just a simple example of debugging a C program. The debugging process can be more complex for larger and more complex programs. However, the steps involved are essentially the same: identify the problem, reproduce the problem, isolate the problem, and fix the problem.</p> <p>We can also use various debuggers such as gdb (a popular one) that help us find out the error.</p>"},{"location":"Beginner-4/#conclusion","title":"Conclusion","text":"<p>In conclusion, mastering debugging and understanding pointers in C is essential for writing robust and efficient code. Debugging is not just about fixing errors; it's a proactive process that enhances code quality. Pointers, while powerful, require careful handling to prevent runtime errors. This documentation has provided insights into debugging techniques and practical exercises with intentional bugs. Embrace debugging as a crucial part of development, and use pointers judiciously to write reliable C code. Happy coding!</p> <p></p>"}]}